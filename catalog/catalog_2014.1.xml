<?xml version="1.0" encoding="utf-8"?>
<catalog>
  <release>2014.1</release>
  <apps>
    <app>
      <revision>1.6</revision>
      <commit_id>e7568fe3f78ac51deb6b15d422ae0ff4ce6e724c</commit_id>
      <name>designutils</name>
      <pkg_require>Vivado 2014.1</pkg_require>
      <company>xilinx</company>
      <company_display>Xilinx, Inc.</company_display>
      <summary>This is a collection of scripts and utility application that are grouped by relevance to querying and analyzing a logical design, principally around the netlist object model.</summary>
      <display>Design Utilities</display>
      <procs>
        <proc>
          <name>bisect_pblock</name>
          <summary>bisect a P block</summary>
        </proc>
        <proc>
          <name>check_cdc_paths</name>
          <summary>checks all the Cross Domain Crossing paths for typical issues</summary>
        </proc>
        <proc>
          <name>clone_cell</name>
          <summary>Clone a cell and connects all the clone input pins to the master input pins. Run after synthesis</summary>
        </proc>
        <proc>
          <name>clone_net_driver</name>
          <summary>Clone the driver cell of a net. Run after synthesis</summary>
        </proc>
        <proc>
          <name>convert_muxfx_to_luts</name>
          <summary>Replaces MUXFX cells with LUT3 cells in an open synthesized design</summary>
        </proc>
        <proc>
          <name>create_diff_ports</name>
          <summary>Creates differential _N port for each _P port in a pinplanning design</summary>
        </proc>
        <proc>
          <name>generate_runs</name>
          <summary>Create all possible combinations of runs</summary>
        </proc>
        <proc>
          <name>get_clock_interaction</name>
          <summary>Return a specific string within the clock interaction report</summary>
        </proc>
        <proc>
          <name>get_connected_ref_pins</name>
          <summary>Return a list of reference pins connected to the pin</summary>
        </proc>
        <proc>
          <name>get_data_through_pins</name>
          <summary>Return the data pins of a single timing path</summary>
        </proc>
        <proc>
          <name>get_host_platform</name>
          <summary>return the host platform (windows|unix)</summary>
        </proc>
        <proc>
          <name>get_inter_slr_nets</name>
          <summary>get all the inter-SLR nets</summary>
        </proc>
        <proc>
          <name>get_leaf_cells</name>
          <summary>get all the leave cells below an instance</summary>
        </proc>
        <proc>
          <name>get_mem</name>
          <summary>queries the kernel for current heap memory of Vivado session</summary>
        </proc>
        <proc>
          <name>get_pid_mem</name>
          <summary>queries the kernel for the heap memory of a specific process</summary>
        </proc>
        <proc>
          <name>get_sll_nets</name>
          <summary>get routed inter-SLR nets that have a VLONG12 cost and over 100 wire shapes on at least one of its nodes</summary>
        </proc>
        <proc>
          <name>get_sll_nodes</name>
          <summary>returns all the sll node objects in the device for matching SLRs</summary>
        </proc>
        <proc>
          <name>gets_regexp</name>
          <summary>returns the next line that matches occurrence of a regular expression in the file</summary>
        </proc>
        <proc>
          <name>highlight_enable_signal_sites</name>
          <summary>highlight the destination sites of the enable signals reported by report_control_set command</summary>
        </proc>
        <proc>
          <name>insert_buffer</name>
          <summary>insert a buffer or any 2-pins cell on a net</summary>
        </proc>
        <proc>
          <name>insert_buffer_chain</name>
          <summary>insert a list of buffers or any 2-pins cells on a net</summary>
        </proc>
        <proc>
          <name>is_fabric_connected</name>
          <summary>Determine if the given pin is connected to a SLICE. For input pins, check just the driver. For output pins, check all loads</summary>
        </proc>
        <proc>
          <name>prettyTable</name>
          <summary>utility to easily create and print tables</summary>
        </proc>
        <proc>
          <name>read_file_regexp</name>
          <summary>returns all lines that match occurrence of a regular expression in the file</summary>
        </proc>
        <proc>
          <name>reapply_iostandard</name>
          <summary>this command queries the tool-chosen defaults from implementation and &quot;apply&quot; them so it looks like the user did it from the beginning. This complies with the bit export restriction that all ios be LOCd and explicitly set to an IO Standard</summary>
        </proc>
        <proc>
          <name>remove_buffer</name>
          <summary>remove a buffer or any 2-pins cell</summary>
        </proc>
        <proc>
          <name>replicate_high_fanout_registers</name>
          <summary>Replicate registers to limit register fanout to maxFan.  Run after synthesis</summary>
        </proc>
        <proc>
          <name>report_all_primitives</name>
          <summary>reports all primitives (LIB_CELL) in the design</summary>
        </proc>
        <proc>
          <name>report_cells_fanout</name>
          <summary>report the fanout of cells matching a REF_NAME pattern</summary>
        </proc>
        <proc>
          <name>report_cells_loc</name>
          <summary>report the location of cells matching a REF_NAME pattern</summary>
        </proc>
        <proc>
          <name>report_critical_hfn</name>
          <summary>report timing critical high fanout nets based on fanout and slack</summary>
        </proc>
        <proc>
          <name>report_hier_util</name>
          <summary>report the cell utilization below hierarchical instances</summary>
        </proc>
        <proc>
          <name>report_parts</name>
          <summary>report all the available parts that match a pattern</summary>
        </proc>
        <proc>
          <name>source_path</name>
          <summary>source a script from a choice of paths</summary>
        </proc>
        <proc>
          <name>timing_report_to_verilog</name>
          <summary>Convert timing paths to a Verilog structural netlist</summary>
        </proc>
        <proc>
          <name>verilog2int</name>
          <summary>Convert a Verilog formatted number into an integer</summary>
        </proc>
        <proc>
          <name>write_slr_pblock_xdc</name>
          <summary>Exports the current SLR placement to pblock constraints in an XDC file</summary>
        </proc>
        <proc>
          <name>write_template</name>
          <summary>generates a Verilog/VHDL stub, instanciation template or testbench for the current design in memory (current_instance)</summary>
        </proc>
      </procs>
    </app>
    <app>
      <revision>1.2</revision>
      <commit_id>05af6727419d7314a024b3c313dfe6fa6f775982</commit_id>
      <name>diff</name>
      <company>xilinx</company>
      <company_display>Xilinx, Inc.</company_display>
      <summary>The Diff App compares two different designs at a time. Designs can be any combination of checkpoints or runs. With two designs loaded into memory this App enables the user to compare reports, lists, or first-class object properties between the two designs.  The output is generated in the form of interactive reporting (stdout), a text report, or an html report. The app can be used to compare a design against a reference or golden design or to dtermine where divergence occurred (isolation of problems and root cause analysis).</summary>
      <display>Design Comparison</display>
      <visible>false</visible>
      <procs>
        <proc>
          <name>delete</name>
          <summary>Wrapper around stooop::delete to delete stooop managed object</summary>
        </proc>
        <proc>
          <name>diff_close_designs</name>
          <summary>This helper command is used to report the sequential line differences between all of the properties of the objects returned from a specific command on each design.</summary>
        </proc>
        <proc>
          <name>diff_lists</name>
          <summary>This helper command is used to report the non-sequential differences between the lists produced when executing a specific command on each design. In other words, if we ran get_cells on two designs and this is what was returned: design_1: a c d, design_2: c d a. Then diff_lists would say that the lists are equivalent. The diff_lists command *does not care about order*.</summary>
        </proc>
        <proc>
          <name>diff_props</name>
          <summary>This helper command is used to report the sequential line differences between the reports produced when executing a specific command on each design.</summary>
        </proc>
        <proc>
          <name>diff_reports</name>
          <summary>This helper command is used to report the sequential line differences between the reports produced when executing a specific command on each design. In other words, if we ran report_clocks -return_string on two designs and this is what was returned: design_1: a b c, design_2: b c a. This helper command is used to report the sequential line differences between all of the properties of the objects returned from a specific command on each design.</summary>
        </proc>
        <proc>
          <name>double_exec</name>
          <summary>This helper command is used to execute any tcl command on both designs.</summary>
        </proc>
        <proc>
          <name>new_diff</name>
          <summary>This helper command is used to create a new diff object. This is the object that difference methods can be called on and differences can be reported.</summary>
        </proc>
        <proc>
          <name>new_report</name>
          <summary>This helper command is used to create a new report object.</summary>
        </proc>
      </procs>
    </app>
    <app>
      <revision>1.0</revision>
      <commit_id>d665d803a749b2f10a9d05228894da7b0eb70595</commit_id>
      <name>ies</name>
      <pkg_require>Vivado 2014.1</pkg_require>
      <company>xilinx</company>
      <company_display>Xilinx, Inc.</company_display>
      <summary>This is a Cadence&amp;reg; Incisive&amp;reg; Enterprise Simulator (IES) integration app that implements the simulation flow in Vivado IDE to allow users to compile, elaborate and simulate a design. To simulate a design using this app, set the target simulator in the simulation settings to &apos;Incisive Enterprise Simulator (IES)&apos; and then click on the &apos;Run Simulation&apos; button in the IDE to launch the simulation. You can also generate simulation scripts for the design in the &apos;scripts only&apos; mode in which case these self-contained generated scripts can be executed in the simulation run directory. The simulation can also be launched from the Tcl console using the launch_simulation command. The list of target simulators can be obtained by running get_simulators Tcl command. The simulation flow for this app requires that this simulator is installed with the license and Xilinx Simulation libraries compiled.</summary>
      <display>Incisive&amp;reg; Enterprise Simulator IES</display>
      <visible>project.enableUnifiedSimulation</visible>
    </app>
    <app>
      <revision>1.0</revision>
      <commit_id>4732f82b901c18e1bdecf5a5b4ba196410e7ef2d</commit_id>
      <name>junit</name>
      <company>xilinx</company>
      <company_display>Xilinx, Inc.</company_display>
      <summary>The JUnit App is built with 3 layers of APIs. The high level API enables a user to run generic tests or a group of predefined tests on demand. The intermediate level API enables a user to call assertions and customize the tests. Both the high level and intermediate level APIs are automatically generating a JUnit report in memory. The low level API enables the user to work directly with the &quot;data graph&quot; in memory. There is a section in the writer class where this in-memory &quot;data graph&quot; is converted to a &quot;junit graph&quot;. The &quot;junit graph&quot; is then just dumped to an XML file.  The conversion from &quot;data graph&quot; to &quot;junit graph&quot; exists to enable users to convert the data to other formats.</summary>
      <display>JUnit Utilities</display>
      <procs>
        <proc>
          <name>assert_exists</name>
          <summary>Asserts that all file exist</summary>
        </proc>
        <proc>
          <name>assert_same</name>
          <summary>Asserts that two values are the same, else a failure is logged</summary>
        </proc>
        <proc>
          <name>format_junit</name>
          <summary>Converts the results of the in-memory data object to JUnit</summary>
        </proc>
        <proc>
          <name>get_report</name>
          <summary>Returns the currently set JUnit API output location</summary>
        </proc>
        <proc>
          <name>get_results</name>
          <summary>Returns the in-memory results, this is a ::struct::graph name. The name of a struct graph is a procedure and is used to configure and retrieve data from the graph object</summary>
        </proc>
        <proc>
          <name>graph_to_xml</name>
          <summary>Write xml file</summary>
        </proc>
        <proc>
          <name>new_stderr</name>
          <summary>Create a new node &apos;stderr&apos; in the provided results object</summary>
        </proc>
        <proc>
          <name>new_stdout</name>
          <summary>Create a new node &apos;stdout&apos; in the provided results object</summary>
        </proc>
        <proc>
          <name>new_testcase</name>
          <summary>Create a new node &apos;testcase&apos; in the provided results object</summary>
        </proc>
        <proc>
          <name>new_testsuite</name>
          <summary>Create a new node &apos;testsuite&apos; in the provided results object</summary>
        </proc>
        <proc>
          <name>new_testsuites</name>
          <summary>Create a new node &apos;testsuites&apos; in the provided results object</summary>
        </proc>
        <proc>
          <name>process_impl_design</name>
          <summary>Used to process an implemented design</summary>
        </proc>
        <proc>
          <name>process_runs</name>
          <summary>Used to post-process runs.</summary>
        </proc>
        <proc>
          <name>process_synth_design</name>
          <summary>Used to process an synthesized design</summary>
        </proc>
        <proc>
          <name>reset_results</name>
          <summary>Resets the in-memory results, if it exists</summary>
        </proc>
        <proc>
          <name>run_command</name>
          <summary>Used to wrap a run step while logging success, errors, and runtimes</summary>
        </proc>
        <proc>
          <name>run_silent</name>
          <summary>Used to wrap any command while logging errors _only_. A JUnitXml entry is not created on success!!</summary>
        </proc>
        <proc>
          <name>run_step</name>
          <summary>Used to wrap a run step while logging success, errors, and runtimes</summary>
        </proc>
        <proc>
          <name>set_report</name>
          <summary>Configures the JUnit API output location</summary>
        </proc>
        <proc>
          <name>set_stderr</name>
          <summary>Adds a stderr entry to the global testsuite and sets it&apos;s content</summary>
        </proc>
        <proc>
          <name>set_stdout</name>
          <summary>Adds a stdout entry to the global testsuite and sets it&apos;s content</summary>
        </proc>
        <proc>
          <name>validate_drcs</name>
          <summary>Checks if any DRCs are found</summary>
        </proc>
        <proc>
          <name>validate_logic</name>
          <summary>Checks for driverless nets and latches</summary>
        </proc>
        <proc>
          <name>validate_messages</name>
          <summary>Checks if Warnings, Critical Warnings, or Errors exist. If Errors are found, then the process is stopped</summary>
        </proc>
        <proc>
          <name>validate_routing</name>
          <summary>Checks for unrouted nets</summary>
        </proc>
        <proc>
          <name>validate_run_properties</name>
          <summary>Logs run walltime. Validates the run is at 100% progress, else logs error and stops process</summary>
        </proc>
        <proc>
          <name>validate_timing</name>
          <summary>Checks for unrouted nets</summary>
        </proc>
        <proc>
          <name>write</name>
          <summary>Write out the output content to a file</summary>
        </proc>
        <proc>
          <name>write_results</name>
          <summary>Write the in-memory results to dist (uses the set_report/get_report location)</summary>
        </proc>
      </procs>
    </app>
    <app>
      <revision>1.0</revision>
      <commit_id>6218187b617deed6a79d8778b2df6f51652a23e1</commit_id>
      <name>modelsim</name>
      <pkg_require>Vivado 2014.1</pkg_require>
      <company>xilinx</company>
      <company_display>Xilinx, Inc.</company_display>
      <summary>This is a Mentor Graphics ModelSim/QuestaSim Simulator integration app that implements the simulation flow in Vivado IDE to allow users to compile, elaborate and simulate a design. To simulate a design using this app, set the target simulator in the simulation settings to &apos;ModelSim/QuestaSim Simulator&apos; and then click on the &apos;Run Simulation&apos; button in the IDE to launch the simulation. You can also generate simulation scripts for the design in the &apos;scripts only&apos; mode in which case these self-contained generated scripts can be executed in the simulation run directory. The simulation can also be launched from the Tcl console using the launch_simulation command. The list of target simulators can be obtained by running get_simulators Tcl command. The simulation flow for this app requires that this simulator is installed with the license and Xilinx Simulation libraries compiled.</summary>
      <display>ModelSim/QuestaSim Simulator</display>
      <visible>project.enableUnifiedSimulation</visible>
    </app>
    <app>
      <commit_id>3d151a50b0718d7c4feaaeb55ccd024bcfe845e4</commit_id>
      <name>myapp</name>
      <company>mycompany</company>
      <company_display>Xilinx, Inc.</company_display>
      <summary>example myapp</summary>
      <procs>
        <proc>
          <name>myproc1</name>
        </proc>
        <proc>
          <name>myproc2</name>
        </proc>
        <proc>
          <name>myproc3</name>
        </proc>
      </procs>
    </app>
    <app>
      <revision>2.0</revision>
      <commit_id>5d4d53c6f247d46cc7021fe2b3007075e9748c11</commit_id>
      <name>projutils</name>
      <pkg_require>Vivado 2014.1</pkg_require>
      <company>xilinx</company>
      <company_display>Xilinx, Inc.</company_display>
      <summary>This is a collection of scripts and utility application that are grouped by relevance to manipulation of projects.</summary>
      <display>Project Utilities</display>
      <procs>
        <proc>
          <name>export_simulation</name>
          <summary>Generate design filelist for the specified simulator for standalone simulation</summary>
        </proc>
        <proc>
          <name>write_project_tcl</name>
          <summary>Export Tcl script for re-creating the current project</summary>
        </proc>
      </procs>
    </app>
    <app>
      <revision>1.0</revision>
      <commit_id>05af6727419d7314a024b3c313dfe6fa6f775982</commit_id>
      <name>tk_tunnel</name>
      <company>xilinx</company>
      <company_display>Xilinx, Inc.</company_display>
      <summary>The Tk_tunnel app can be used to launch a Tcl/Tk 8.5 server outside of Vivado using a standalone Tcl shell, and pass commands from Vivado console to the Tk shell. One of the benefits of this app is to provide a bridge for simple Tk-based GUI.</summary>
      <display>Tk Tunnel</display>
      <visible>false</visible>
      <procs>
        <proc>
          <name>accept_connection</name>
          <summary>This proc is the callback function when the server receives a connection request</summary>
        </proc>
        <proc>
          <name>ask</name>
        </proc>
        <proc>
          <name>broadcast</name>
          <summary>This command broadcasts a command / response to all clients from the server</summary>
        </proc>
        <proc>
          <name>connect_to_server</name>
          <summary>This proc is called to connect a client to a server, it will wait until it is connected</summary>
        </proc>
        <proc>
          <name>exec_push_return</name>
          <summary>Executes a command locally and broadcasts the return to the client (called by rexec_wait)</summary>
        </proc>
        <proc>
          <name>hide_server_start</name>
        </proc>
        <proc>
          <name>launch_server</name>
          <summary>Starts the server that the Tk commands will be sent to (launched from client)</summary>
        </proc>
        <proc>
          <name>rexec</name>
          <summary>Executes a command on the Tk server (remote exec)</summary>
        </proc>
        <proc>
          <name>rexec_wait</name>
          <summary>Executes a command on the Tk server (remote exec), and waits for the response/return</summary>
        </proc>
        <proc>
          <name>socket_event</name>
          <summary>This proc is called when a socket event occurs</summary>
        </proc>
        <proc>
          <name>start_client</name>
          <summary>Starts the client that will be sending the Tk commands</summary>
        </proc>
        <proc>
          <name>start_server</name>
          <summary>This command launches the listening service on the server</summary>
        </proc>
        <proc>
          <name>stdin_event</name>
          <summary>This proc is called when a stdin event occurs</summary>
        </proc>
        <proc>
          <name>wait</name>
          <summary>This proc will wait for a specified time</summary>
        </proc>
        <proc>
          <name>wait_for_response</name>
          <summary>Waits for client_return to be set (called by rexec_wait)</summary>
        </proc>
      </procs>
    </app>
    <app>
      <revision>1.1</revision>
      <revision_history>Fixed reporting issue in report_io_reg</revision_history>
      <commit_id>4ba4d8b1144918b01ebe57b2758016079acd72d1</commit_id>
      <name>ultrafast</name>
      <pkg_require>Vivado 2014.1</pkg_require>
      <company>xilinx</company>
      <company_display>Xilinx, Inc.</company_display>
      <summary>This app is a collection of scripts that are used by the UltraFast Design Methodology. Refer to the user guide UG949 &apos;UltraFast Design Methodology Guide for the Vivado Design Suite&apos; for further information.</summary>
      <display>UltraFast Design Methodology</display>
      <procs>
        <proc>
          <name>check_bd_axi_interface</name>
          <summary>Report AXI Interconnect Internal Blocks for Every AXI Master and AXI Slave in an AXI Interconnect instance</summary>
        </proc>
        <proc>
          <name>check_pll_connectivity</name>
          <summary>Report MMCM/PLL information</summary>
        </proc>
        <proc>
          <name>create_cdc_reports</name>
          <summary>Create CDC report for each clock-pair in the design</summary>
        </proc>
        <proc>
          <name>report_clock_topology</name>
          <summary>Generates a Clock Topology Report</summary>
        </proc>
        <proc>
          <name>report_io_reg</name>
          <summary>Report I/O ports information</summary>
        </proc>
        <proc>
          <name>report_reset_signals</name>
          <summary>Generate Report for Control Signals (Reset/Set/Clear/Preset)</summary>
        </proc>
      </procs>
    </app>
    <app>
      <revision>1.0</revision>
      <commit_id>6218187b617deed6a79d8778b2df6f51652a23e1</commit_id>
      <name>vcs</name>
      <pkg_require>Vivado 2014.1</pkg_require>
      <company>xilinx</company>
      <company_display>Xilinx, Inc.</company_display>
      <summary>This is a Synopsys VCS&amp;reg;/VCS-MX Simulator integration app that implements the simulation flow in Vivado IDE to allow users to compile, elaborate and simulate a design. To simulate a design using this app, set the target simulator in the simulation settings to &apos;Verilog Compiler Simulator (VCS)&apos; and then click on the &apos;Run Simulation&apos; button in the IDE to launch the simulation. You can also generate simulation scripts for the design in the &apos;scripts only&apos; mode in which case these self-contained generated scripts can be executed in the simulation run directory. The simulation can also be launched from the Tcl console using the launch_simulation command. The list of target simulators can be obtained by running get_simulators Tcl command. The simulation flow for this app requires that this simulator is installed with the license and Xilinx Simulation libraries compiled.</summary>
      <display>Verilog Compiler Simulator VCS&amp;reg;</display>
      <visible>project.enableUnifiedSimulation</visible>
    </app>
    <app>
      <revision>1.0</revision>
      <commit_id>05af6727419d7314a024b3c313dfe6fa6f775982</commit_id>
      <name>xsim</name>
      <pkg_require>Vivado 2014.1</pkg_require>
      <company>xilinx</company>
      <company_display>Xilinx, Inc.</company_display>
      <summary>This is a Xilinx Vivado Simulator integration app that implements the simulation flow in Vivado IDE to allow users to compile, elaborate and simulate a design. To simulate a design using this app, set the target simulator in the simulation settings to &apos;Vivado Simulator&apos; and then click on the &apos;Run Simulation&apos; button in the IDE to launch the simulation. You can also generate simulation scripts for the design in the &apos;scripts only&apos; mode in which case these self-contained generated scripts can be executed in the simulation run directory. The simulation can also be launched from the Tcl console using the launch_simulation command. The list of target simulators can be obtained by running get_simulators Tcl command.</summary>
      <display>Vivado Simulator</display>
      <visible>project.enableUnifiedSimulation</visible>
    </app>
  </apps>
</catalog>
