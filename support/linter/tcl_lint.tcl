#!/usr/bin/tclsh

package provide lint 1.0

package require Tcl 8.5

## \mainpage  TCL LINTER
#
#  The point here is to make it as easy as possible to
#  conform to the tcl coding guidelines.
# \section tut_sec Quick Start
# 
#  to use this just type tcl_linter.tcl <filename>
# \section user_sec User Guide
#
#  The tcl linter is a tool which makes it as easy as possible to
#  conform with the coding guidelines.  
#
# \ref grp_coding_standards is a description of the coding standards
# enforced by this linter
#
# \section dev_sec Developer Guide
#
#  contains information on the modification of
#  this script, its architecture, and how to add
#  new tests to it if you would like.
# \file tcl_lint.tcl
#  This file contains all of the code for the linter.  Perhaps
#  later we will split it up into more reusable modules, but 
#  while its under rapid development, its gunna be in one file.
#  Note to self: probably don't want this section in the coding
#  standard
#
# \section Acknowledgments
#
# This code uses Lars Hellstro"m's tcl parser 
# (see http://wiki.tcl.tk/9649)
# to help with analysis.  

## \defgroup  grp_coding_standards  Coding Standards
# 
#  \section sec_valid_tcl Script must be valid tcl
#   This kind of goes without saying, but it is worth checking for.
#   Tcl is actually a difficult language to check 100% for, and 
#   this linter makes no claims to 100% correctness, but it does do some
#   elementary checks, and will warn the user if there are any problems.
# 
#  \section sec_null_ptr Script must not access database items which have been deleted:
#  Here is an example from a real customer bug (#551522)
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  create_project proj_port1 -w . -part xc6vlx75tff484-1
#  set_property design_mode PinPlanning [get_filesets sources_1]
#  open_io_design
#  set myport [ create_port port1 -dir in ]
#  close_design
#  open_io_design
#  report_prop $myport
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#  
# \section nmspc_sec If the scripts provides a library, it must provide a matching package name and namespace
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# package provide simple_count 1.0
# namespace eval simple_count {
#     variable counter 0
# }
#
#
# ## this has proper documentation
#proc exlib::bump {} {
#    variable counter
#    set counter [incr counter]
#}

## so does this
#
#
#proc exlib::get {} {
#    variable counter
#    return $counter
#}
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#
#
#  \section proc_doc_sec Proceedures must be documented with doxygen
#  This is very easy:  all you have to do is start a comment block with 
#  two "#" signs, like as follows:
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  ## this procedure counts the number of nets
#  #  only works at one level of hierarcy
#  proc count_nets {} {
#      return [llength [get_nets]]
#  }
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
# doxygen will automatically extract the format of how the command is to be invoked,
# by looking at the "proc" commmand which creates it.  But it is recommended
# that you also in the comment include helpful info as to what the command arguments
# should be set to, and what the values of the error codes of the function are, if any.


## \defgroup grp_developer_guide Developer's Guide
#
# \section sec_grp_def_guide_intro Introduction
#
# If you are interested in 
# * understanding how the tcl linter works
# * fixing a bug in the tcl linter
# * adding a new coding guideline to the check
#
# you have come to the right place.  
#
# \section sec_arch Architecture of the Tcl Linter
#
# The tcl linter consists of:
# * a tcl parser, which parses an input script into a parse tree
# * a series of checkers
# There is one checker for each of the enforced coding guidelines.
#
# A checker is simply a tree walker---it walks over the parse
# tree generated by the parser, and tries to detect any
# violations of the coding guideline which it is enforcing.  
#
# \section sec_flow Control Flow
#
# The control-flow is very simple.  What happens is:
# * The programs reads-in the script from a user-supplied filename
# * The script is parsed, and the parse tree is stored for further processing
# * Each of the checkers is run in turn.
# * At the end, a report is printed out which indicates the violations found.
#


# some utilities
namespace eval stack {
    proc push { stack value } {
	upvar 1 $stack iStack
	lappend iStack $value
	return $iStack
    }
    
    proc pop { stack } {
	upvar 1 $stack iStack
	set returner [lindex $iStack end]
	set iStack [lrange $iStack 0 end-1]
	return $returner
    }
}

namespace eval documentation_utils {
    ## routines to extract stuff.
    proc ::documentation_utils::get_documentation_section { procBody sectionName section } {
	# Summary : extracts the documentation section named $section from $body
	
	# Argument Usage :
	# procBody     : a string which is the body of a procedure
	# sectionName  : a string which names the section to be extracted
	# section      : if the section is found, $section contains the extracted text
	
	# Return Value:
	# returns 1 of the section was successfully found and extracts.
	#
	# If the function returns 1, then $section is populated with the extracted
	# section, stripped of the leading # on each line
	#
	# If the function returns 0, then $section is undefined.
	
	# Categories:
	# documentation
	# help system
	
	# pass the section by value
	upvar $section iSection
	
	if { [array exists iSections] } {
	    array unset iSection
	}
	
	if { [info exists iSection] } {
	    unset iSection
	}
	
	# initialize it to {}
	set iSection {}
	
	# prepair the search string
	set regExpString "\#\[ \\t\]*$sectionName\[ \\t\]*:\[ \\t\]*(\[^\\n\]*)\n"
	
	# find where the section starts
	if { ![regexp -indices $regExpString $procBody nspec pos] } {
	    return 0
	}
	
	# Handle the stuff on the same line as the section tag:
	set firstLine [string range $procBody [lindex $pos 0] [lindex $pos 1]]
	if { "" != $firstLine } {
	    append iSection "$firstLine\n"
	}
	
	set startSpecPos [expr [lindex $pos 1] + 2]
	
	# find where the section ends -- must end with two consecutive newlines
	if { ![regexp -start [lindex $nspec 0] -indices {\n[\s]*\n} $procBody pos] } {
	    return 0
	}
	set endSpecPos [expr [lindex $pos 0] -1 ]
	
	# extract the text
	set buffer [string trim [string range $procBody $startSpecPos $endSpecPos]]
	
	# now see that each line is a comment line
	set lines [split $buffer "\n"]
	
	foreach line $lines {
	    # just to make it easier to process
	    set line [string trim $line]
	    
	    # all other lines but the first one must be 
	    if { 0 != [string first "\#" $line ] } {
		return 0
	    }
	    
	    # remove the space trailing the pound sign--if indeed it is a space
	    if { 0==[string first "# " $line] } {
		set line [string range $line 2 end]
	    } elseif { 0==[string first "#" $line] } {
		set line [string range $line 1 end]
	    }
	    
	    # now append it to the output
	    append iSection "$line\n"
	}
	
	# success!!
	return 1
    }
}
    



## this is to give each of the errors reported a standard
#  look when printed out.  This namespace holds the code
#  to format/print the errors, as well as some supporting
#  utility code to help it out.
namespace eval error_reporter {
    variable errors

    proc ::error_reporter::xappend { errors_var msg } {
	upvar 1 $errors_var errors
        if {[string length $errors]} {
            append errors "\n"
        }
        append errors $msg
    }
    
    ## this should be called when you have an error at a specific locaion
    proc ::error_reporter::error { interval text } {
	variable errors
	
	set line_number [count_lines $interval]

	set error_string "Error at line $line_number : $text"
	
	xappend errors $error_string
    }
    
    ## this should be called when you do not have an error at a specific location
    #  e.g. if there is a missing namespace or package declaration
    proc ::error_reporter::error_no_line { text } {
	variable errors
	
	set error_string "Error: $text"
	
	xappend errors $error_string
    }


    ## this takes an interval from the  parse tree and calculates what
    #  a line number near (hopefully exactly on) the interval.  It is
    #  a scaffolding implementation right now; note we copy most of the
    #  input file every time its run.  Please replace as necessary.
    proc ::error_reporter::count_lines { interval } {
	set initial_segment [string range $file_handling::file_contents 0 [lindex $interval 0]]
	
	set rc [expr 1 + [regexp -line -all "\n" $initial_segment]]
	
	#    puts "interval = $interval"
	#    puts "initial_segment = $initial_segment"
	#    puts "rc = $rc"
	
	return $rc
    }
}


##  This Implements a very basic tcl parser
namespace eval parse_tcl {
    
    ## just just gets rid of the whitespace
    proc ::parse_tcl::flush_whitespace {script index_var cmdsep} {
	upvar 1 $index_var index
	if {[
	     if { $cmdsep } then {
		 regexp -start $index -- {\A([ \t-\r;]|\\\n)+} $script match
	     } else {
		 regexp -start $index -- {\A([ \t\v\f\r]|\\\n)+} $script match
	     }
	    ]} then {
	    incr index [string length $match]
	    return [string length $match]
	} else {
	    return 0
	}
    }

    ## 
    proc ::parse_tcl::parse_command {script index_var nested} {
	upvar 1 $index_var index
	flush_whitespace $script index 1
	switch -- "[string index $script $index]$nested" {#0} - {#1} {
	    regexp -start $index -indices -- {\A#([^\n\\]|\\.)*(\\$)?}\
		$script interval
	    incr index
	    regsub -all -- {\\\n[ \t]*}\
		[string range $script $index [lindex $interval 1]]\
		{ } text
	    set index [expr {[lindex $interval 1] + 1}]
	    return [list Nc $interval $text]
	} 0 - 1 - \]1 {
	    return [list Np "" ""]
	}
	set res [list Cd [list $index ""] ""]
	set next [parse_word $script index $nested]
	while {[lindex $next 0] ne "Np"} {
	    lappend res $next
	    set next [parse_word $script index $nested]
	}
	lset res 1 1 [lindex $res end 1 1]
        return $res
    }

    ## this is the top-level command which is called most times
    proc ::parse_tcl::basic_parse_script {script} {
	set index 0
	set res [list Rs [list $index ""] ""]
	while {[lindex [set next [parse_command $script index 0]] 0] ne "Np"} {
	    lappend res $next
	}
	incr index -1
	lset res 1 1 $index
	return $res
    }

    ##
    proc ::parse_tcl::parse_word {script index_var nested} {
	upvar 1 $index_var index
	switch -- [string index $script $index] \{ {
	    parse_braced_word $script index $nested
	} \" {
	    parse_quoted_word $script index $nested
	} "" - \; - \n {
	    list Np "" ""
	} \] {
	    if {$nested} then {
		list Np "" ""
	    } else {
		parse_raw_word $script index $nested
	    }
	} default {
	    parse_raw_word $script index $nested
	}
    }
    
    ##
    proc ::parse_tcl::parse_braced_word {script index_var nested} {
	upvar 1 $index_var index
	set res [list Lb [list $index ""]]
	set depth 1
	set text ""
	incr index
	while {$depth>0} {
	    regexp -start $index -- {\A([^{}\\]|\\[^\n])*} $script match
	    append text $match
	    incr index [string length $match]
	    switch -- [string index $script $index] \{ {
		incr depth
		incr index
		append text \{
	    } \} {
		incr depth -1
		incr index
		if {$depth} { append text \} }
	    } \\ {
		if {[regexp -start $index -- {\A\\\n[ \t]*} $script match]}\
		    then {
			incr index [string length $match]
			append text { }
		    } else {
			append text \\
			    break
		    }
	    } "" {
		break
	    }
	}
	if {$depth>0} then {
	    lset res 1 1 $index
	    lappend res $text [list Ne [list "" $index] {missing close-brace}]
	    lset res 3 1 0 [incr index]
	    return $res
	}
	lset res 1 1 [expr {$index - 1}]
        lappend res $text
	if {[flush_whitespace $script index 0]} then {return $res}
	switch -- [string index $script $index] \n - \; - {} {
	    return $res
	} \] {
	    if {$nested} then {return $res}
	}
	lappend res [list Ne [list $index [expr {$index - 1}]]\
			 {missing space after close-brace}]
        return $res
    }
    
    ##
    proc ::parse_tcl::parse_quoted_word {script index_var nested} {
	upvar 1 $index_var index
	set res [list Lq [list $index ""] ""]
	set text ""
	incr index
	while {1} {
	    switch -- [string index $script $index] \\ {
		lappend res [parse_backslash $script index]
		append text [lindex $res end 2]
	    } \$ {
		lappend res [parse_dollar $script index]
		lset res 0 Mq
	    } \[ {
		lappend res [parse_bracket $script index]
		lset res 0 Mq
	    } \" {
		incr index
		break
	    } "" {
		lappend res [list Ne [list $index [expr {$index - 1}]]\
				 {missing close-quote}]
		break
	    } default {
		regexp -start $index -- {[^\\$\["]*} $script match
                set t $index
                incr index [string length $match]
                lappend res [list Lr [list $t [expr {$index - 1}]] $match]
                append text $match
           }
         }

          lset res 1 1 [expr {$index - 1}]
          if {[lindex $res 0] eq "Lq"} then {
             lset res 2 $text
       if {[llength $res] == 4 && [lindex $res 3 0] eq "Lr"} then {
          set res [lrange $res 0 2]
       }
    }
    if {[flush_whitespace $script index 0]} then {return $res}
    switch -- [string index $script $index] \n - \; - {} {
       return $res
    } \] {
       if {$nested} then {return $res}
    }
    lappend res [list Ne [list $index [expr {$index - 1}]]\
      {missing space after close-quote}]
    return $res

 }

#"#
proc ::parse_tcl::parse_raw_word {script index_var nested} {
    upvar 1 $index_var index
    set res [list]
    set type Lr
    set interval [list $index]
    set text ""
    while {1} {
       switch -- [string index $script $index] \\ {
          if {[string index $script [expr {$index+1}]] eq "\n"} then {
             break
          }
          lappend res [parse_backslash $script index]
          append text [lindex $res end 2]
          continue
       } \$ {
          lappend res [parse_dollar $script index]
          set type Mr
          continue
       } \[ {
          lappend res [parse_bracket $script index]
          set type Mr
          continue
       } \t - \n - \v - \f - \r - " " - \; - "" {
          break
       }
       if {$nested} then {
          if {![
             regexp -start $index -- {\A[^\\$\[\]\t-\r ;]+} $script match
          ]} then {break}
       } else {
          regexp -start $index -- {\A[^\\$\[\t-\r ;]+} $script match
       }
       set t $index
       incr index [string length $match]
       lappend res [list Lr [list $t [expr {$index - 1}]] $match]
       append text $match
    }
    if {[llength $res]==1} then {
       set res [lindex $res 0]
    } else {
       lappend interval [expr {$index - 1}]
       if {$type ne "Lr"} then {set text ""}
       set res [linsert $res 0 $type $interval $text]
    }
    flush_whitespace $script index 0
    return $res
 }

##
proc ::parse_tcl::parse_backslash {script index_var} {
    upvar 1 $index_var index
    set start $index
    incr index
    set ch [string index $script $index]
    set res [list Lr [list $index $index] $ch]
    switch -- $ch a {
       set res [list Sb [list $start $index] \a $res]
    } b {
       set res [list Sb [list $start $index] \b $res]
    } f {
       set res [list Sb [list $start $index] \f $res]
    } n {
       set res [list Sb [list $start $index] \n $res]
    } r {
       set res [list Sb [list $start $index] \r $res]
    } t {
       set res [list Sb [list $start $index] \t $res]
    } v {
       set res [list Sb [list $start $index] \v $res]
    } x {
       if {[regexp -start [expr {$index + 1}] -- {\A[0-9A-Fa-f]+}\
         $script match]} then {
          scan [string range $match end-1 end] %x code
          incr index [string length $match]
          lset res 1 1 $index
          lset res 2 "x$match"
          set res [list Sb [list $start $index]\
            [format %c $code] $res]
       } else {
          set res [list Sb [list $start $index] x $res]
       }
    } u {
       if {[regexp -start [expr {$index + 1}] -- {\A[0-9A-Fa-f]{1,4}}\
         $script match]} then {
          scan $match %x code
          incr index [string length $match]
          lset res 1 1 $index
          lset res 2 "u$match"
          set res [list Sb [list $start $index]\
            [format %c $code] $res]
       } else {
          set res [list Sb [list $start $index] u $res]
       }
    } \n {
       regexp -start [expr {$index + 1}] -- {\A[ \t]*} $script match
       incr index [string length $match]
       lset res 1 1 $index
       lset res 2 "\n$match"
       set res [list Sb [list $start $index] " " $res]
    } "" {
       return [list Sb [list $start $start] \\]
    } default {
       if {[regexp -start $index -- {\A[0-7]{1,3}} $script match]} then {
          scan $match %o code
          incr index [expr {[string length $match]-1}]
          lset res 1 1 $index
          lset res 2 $match
          set res [list Sb [list $start $index] [format %c $code] $res]
       } else {
          set res [list Sb [list $start $index] $ch $res]
       }

    }
    incr index
    return $res
 }

##
proc ::parse_tcl::parse_bracket {script index_var} {
    upvar 1 $index_var index
    set res [list Sc [list $index ""] ""]
    incr index
    while {[lindex [set next [parse_command $script index 1]] 0] ne "Np"} {
       lappend res $next
    }
    if {[string index $script $index] eq "\]"} then {
       lset res 1 1 $index
       incr index
       return $res
    } else {
       lappend res [list Ne [list $index [expr {$index-1}]]\
			"missing close-bracket"]
       lset res 1 1 [expr {$index-1}]
	
       return $res
    }
 }

## I guess this is the regular expression for a variable name?
set ::parse_tcl::varname_RE {\A(\w|::)+}

##
proc ::parse_tcl::parse_dollar {script index_var} {
    upvar 1 $index_var index
    set res [list "" [list $index ""] ""]
    incr index
    if {[string index $script $index] eq "\{"} then {
       lset res 0 Sv
       set end [string first \} $script $index]
       if {$end<0} then {
          set end [expr {[string length $script] - 1}]
          lappend res [list Lb [list $index $end]\
            [string range $script [expr {$index + 1}] end]]\
            [list Ne [list [expr {$end+1}] $end]\
              {missing close-brace for variable name}]
       } else {
          lappend res [list Lb [list $index $end]\
            [string range $script [expr {$index + 1}] [expr {$end-1}]]]
       }
       lset res 1 1 $end
       set index [expr {$end + 1}]
       return $res
    }
    variable varname_RE
    if {![regexp -start $index -- $varname_RE $script match]} then {
       if {[string index $script $index] eq "("} then {
          set match ""
       } else {
          return [list Lr [list [lindex $res 1 0] [lindex $res 1 0]] \$]
       }
    }
    set t $index
    incr index [string length $match]
    lappend res [list Lr [list $t [expr {$index-1}]] $match]
    if {[string index $script $index] ne "("} then {
       lset res 0 Sv
       lset res 1 1 [lindex $res 3 1 1]
       return $res
    }
    lset res 0 Sa
    incr index
    set subres [list Lr [list $index ""] ""]
    lappend res ""
    set text ""
    while {1} {
       switch -- [string index $script $index] \\ {
          lappend subres [parse_backslash $script index]
          append text [lindex $subres end 2]
       } \$ {
          lappend subres [parse_dollar $script index]
          lset subres 0 Mr
       } \[ {
          lappend subres [parse_bracket $script index]
          lset subres 0 Mr
       } ) {
          lset subres 1 1 [expr {$index - 1}]
          break
       } "" {
          lappend res\
            [list Ne [list $index [incr index -1]] {missing )}]
          lset subres 1 1 $index
          break
       } default {
          regexp -start $index -- {[^\\$\[)]*} $script match
          set t $index
          incr index [string length $match]
          lappend subres [list Lr [list $t [expr {$index - 1}]] $match]
          append text $match
       }
    }
    if {[lindex $subres 0] eq "Lr"} then {lset subres 2 $text}
    if {[llength $subres] == 4} then {set subres [lindex $subres 3]}
    lset res 1 1 $index
    incr index
    lset res 4 $subres
    return $res
 }

##
 # The following are utility procedures:
 #
proc ::parse_tcl::format_tree {tree base step} {
    set res $base
    append res \{ [lrange $tree 0 1] { }
    if {[regexp {[\n\r]} [lindex $tree 2]]} then {
	append res [string range [list "[lindex $tree 2]\{"] 0 end-2]
    } else {
	append res [lrange $tree 2 2]
    }
    if {[llength $tree]<=3} then {
	append res \}
	return $res
    } elseif {[llength $tree] == 4 &&\
		  [string match {S[bv]} [lindex $tree 0]]} then {
	append res " " [format_tree [lindex $tree 3] "" ""] \}
	return $res
    }
    append res \n
    foreach subtree [lrange $tree 3 end] {
       append res [format_tree $subtree $base$step $step] \n
    }
    append res $base \}
 }

## Very useful when handling nested intervals
proc ::parse_tcl::offset_intervals {tree offset} {
    set res [lrange $tree 0 2]
    foreach i {0 1} {
	lset res 1 $i [expr {[lindex $res 1 $i] + $offset}]
    }
    foreach subtree [lrange $tree 3 end] {
	lappend res [offset_intervals $subtree $offset]
    }
    return $res
}

##
proc ::parse_tcl::reparse_Lb_as_script {tree_var index parsed} {
    upvar 1 $tree_var tree
    set node [lindex $tree $index]
    switch -- [lindex $node 0] Lb - Lr - Lq {
       set base [expr {[lindex $node 1 0] + 1}]
	if {[lindex $node 0] eq "Lb"} then {
          set script [string range $parsed $base\
            [expr {[lindex $node 1 1] - 1}]]
       } else {
          set script [lindex $node 2]
       }
       lset tree $index\
         [offset_intervals [basic_parse_script $script] $base]
       if {[lindex $node 0] eq "Lb"} then {
          return 2
       } else {
          return 1
       }
    } default {
       return 0
    }
}

##
proc ::parse_tcl::walk_tree {tree_var index_var args} {
    upvar 1 $tree_var tree $index_var idxL
    set idxL [list]
    set i 0
    while {$i>=0} {
       if {$i==0} then {
          uplevel 1 [list switch -regexp --\
            [lindex [lindex $tree $idxL] 0] $args]
          set i 3
       } elseif {$i < [llength [lindex $tree $idxL]]} then {
          lappend idxL $i
          set i 0
       } elseif {[llength $idxL]} then {
          set i [lindex $idxL end]
          set idxL [lrange $idxL 0 end-1]
          incr i
       } else {
          set i -1
       }
    }
}

##
proc ::parse_tcl::simple_parse_script {script} {
    set tree [parse_tcl::basic_parse_script $script]
    walk_tree tree indices Cd {
	switch -- [lindex [lindex $tree $indices] 3 2] if {
          for {set i 3} {$i < [llength [lindex $tree $indices]]}\
            {incr i} {
             switch -- [lindex [lindex $tree $indices] $i 2]\
               if - elseif {
                incr i; continue
             } then - else {
                incr i
             }
             parse_tcl::reparse_Lb_as_script tree\
               [linsert $indices end $i] $script
          }
       } while {
          parse_tcl::reparse_Lb_as_script tree [linsert $indices end 5]\
            $script
       } for {
          parse_tcl::reparse_Lb_as_script tree [linsert $indices end 4]\
            $script
          parse_tcl::reparse_Lb_as_script tree [linsert $indices end 6]\
            $script
          parse_tcl::reparse_Lb_as_script tree [linsert $indices end 7]\
            $script
       } foreach {
          parse_tcl::reparse_Lb_as_script tree [linsert $indices end end]\
            $script
       } catch {
          parse_tcl::reparse_Lb_as_script tree [linsert $indices end 4]\
            $script
       } proc {
          parse_tcl::reparse_Lb_as_script tree [linsert $indices end 6]\
            $script
       }
    }
    return $tree
}
}


## This is a very basic example of a parse tree walker. What it does is
# simply walks over the parse treee and reconstitutes the original script
# from the parse tree.  In other words, it does  exactly what it says: it 
# unparses it.  
# 
# Use this as a basic template: to create your own parse tree walker,
# just cut-n-paste this code and modify it for your own purposes.
namespace eval unparse_tcl {

    ## top level routine to call
    proc ::unparse_tcl::unparse {tree} {
	eval $tree
    }

    ## This handles literal text which is not delimited by any quotes or braces,
    ## e.g. a variable name or a procedure name
    proc ::unparse_tcl::Lr {interval text args} {
	return $text
    }

    ## This is called on text which is delimited by braces
    proc ::unparse_tcl::Lb {interval text args} {
	return \{$text\}
    }

    ## This is called on literal text which is delimited by braces
    proc ::unparse_tcl::Lq {interval text args} {
	return \"$text\"
    }

    ## called whenever a backslash subsitution happens
    proc ::unparse_tcl::Sb {interval text args} {
	return "\\$text"
    }

    ## called whenever a scalar variable substitution happens -- the value of $cell e.g.
    proc ::unparse_tcl::Sv {interval text args} {
	return "\$[eval [lindex $args 0]]"
    }

    ## called on array substitution
    proc ::unparse_tcl::Sa {interval text args} {
	foreach a [lrange $args 1 end] {
	    append result [eval $a]
	}
	return "\$[eval [lindex $args 0]]($result)"
    }

    ##  command substitution-- called when [commmand is executed] 
    proc ::unparse_tcl::Sc {interval text args} {
	foreach a $args {
	    append cmd " " [eval $a]
	}
	return \[${cmd}\]
    }

    ## merge type--- honestly I don't know what the heck these are
    proc ::unparse_tcl::Mr {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return ${result}
    }

    ## ditto
    proc ::unparse_tcl::Mq {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return \"${result}\"
    }

    ## commands without {*}-construction
    proc ::unparse_tcl::Cd {interval text args} {
	foreach a $args {
	    append cmd [eval $a] " "
	}
	return ${cmd}
    }

    ##
    proc ::unparse_tcl::Rs {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return \{\n$cmd\n\}
    }

    ##
    proc ::unparse_tcl::Nc {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }

    ##
    proc ::unparse_tcl::Ne {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }
}


# Check namespace export requirements
#  1.  namespace export <proc-list>   may not contain wildcards
namespace eval check_namespace_export {

    variable current_namespace
    set current_namespace {}

    proc ::check_namespace_export::push_namespace {ns} {
        variable current_namespace
        if {[string length $current_namespace] > 0} {
            append current_namespace ::
        }
        append current_namespace $ns
    }

    proc ::check_namespace_export::pop_namespace {} {
        variable current_namespace
        set current_namespace [string range $current_namespace 0 [string last "::" $current_namespace]-1]
    }

    ## top level routine to call
    proc ::check_namespace_export::walk {tree} {
	eval $tree
    }

    ## This handles literal text which is not delimited by any quotes or braces,
    ## e.g. a variable name or a procedure name
    proc ::check_namespace_export::Lr {interval text args} {
        if { "namespace" == $text } {
            return "namespace"
        }
        if { "eval" == $text } {
            return "eval"
        }
        if { "export" == $text } {
            return "export"
        }
	return $text
    }

    ## This is called on text which is delimited by braces
    proc ::check_namespace_export::Lb {interval text args} {
	return UNKNOWN
    }

    ## This is called on literal text which is delimited by braces
    proc ::check_namespace_export::Lq {interval text args} {
	return \"$text\"
    }

    ## called whenever a backslash subsitution happens
    proc ::check_namespace_export::Sb {interval text args} {
	return "\\$text"
    }

    ## called whenever a scalar variable substitution happens -- the value of $cell e.g.
    proc ::check_namespace_export::Sv {interval text args} {
	return "\$[eval [lindex $args 0]]"
    }

    ## called on array substitution
    proc ::check_namespace_export::Sa {interval text args} {
	foreach a [lrange $args 1 end] {
	    append result [eval $a]
	}
	return "\$[eval [lindex $args 0]]($result)"
    }

    ##  command substitution-- called when [commmand is executed] 
    proc ::check_namespace_export::Sc {interval text args} {
	foreach a $args {
	    append cmd " " [eval $a]
	}
	return \[${cmd}\]
    }

    ## merge type--- honestly I don't know what the heck these are
    proc ::check_namespace_export::Mr {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return ${result}
    }

    ## ditto
    proc ::check_namespace_export::Mq {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return \"${result}\"
    }

    ## commands without {*}-construction
    proc ::check_namespace_export::Cd {interval text args} {

        variable current_namespace
        
	foreach a $args {
	    lappend cmd [eval $a]
	}

        set command_type [lindex $cmd 0]

        if { "namespace" == $command_type } {
            set namespace_arg_type [lindex $cmd 1]

            if { "eval" == $namespace_arg_type } {
                set namespace_name [lindex [lindex $args 2] 2]
                set namespace_body [lindex [lindex $args 3] 2]
		set namespace_body_interval [lindex [lindex $args 3] 1]

		# parse it
		set namespace_block_parse [parse_tcl::basic_parse_script $namespace_body]
		
		# now dork offset the intervals, so we count the correct linenumbers...
		set namespace_block_parse [parse_tcl::offset_intervals $namespace_block_parse [lindex $namespace_body_interval 0]]

                push_namespace $namespace_name
                check_namespace_export::walk $namespace_block_parse
                pop_namespace
            }

            if { "export" == $namespace_arg_type } {
                set namespace_exported [lrange $args 2 end]
                foreach exp $namespace_exported {
                    set x [lindex $exp 2]
                    if {[string first "*" $x] >= 0} {
                        set interval [lindex $exp 1]
                        error_reporter::error $interval "no wildcards are allowed in export : $x"
                    }
                }
            }
        }
	return ${cmd}
    }

    ##
    proc ::check_namespace_export::Rs {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }

    ##
    proc ::check_namespace_export::Nc {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }

    ##
    proc ::check_namespace_export::Ne {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }
}

## This is a very basic example of a parse tree walker. What it does is
# simply walks over the parse treee and reconstitutes the original script
# from the parse tree.  In other words, it does  exactly what it says: it 
# unparses it.  
# 
# Use this as a basic template: to create your own parse tree walker,
# just cut-n-paste this code and modify it for your own purposes.
namespace eval check_duplicate_symbols {
    variable symbol_table [dict create]
    
    variable namespace_stack {}
    
    proc ::check_duplicate_symbols::accumulate_symbols_for_file { filename } {
	puts "processing filename : $filename"
	
	# snarf file contents
	set fp [open $filename "r"]
	set file_contents [read $fp]
	close $fp
	
	# parse it
	set parse [parse_tcl::basic_parse_script $file_contents]
	
	# walk it
	::check_duplicate_symbols::walk $parse
    }
    
    
    proc ::check_duplicate_symbols::accumulate_symbols {} {
	variable symbol_table [dict create]
	set directory "~/t"
	set filenames [glob -directory $directory *.tcl]
	
	foreach filename $filenames {
	    ::check_duplicate_symbols::accumulate_symbols_for_file $filename
	}
    }
    
    
    proc ::check_duplicate_symbols::check_symbols { parse } {
    	accumulate_symbols
    }
    
    
    ## top level routine to call
    proc ::check_duplicate_symbols::walk {tree} {
	eval $tree
    }
    
    
    ## This handles literal text which is not delimited by any quotes or braces,
    ## e.g. a variable name or a procedure name
    proc ::check_duplicate_symbols::Lr {interval text args} {
	return $text
    }
    
    
    ## This is called on text which is delimited by braces
    proc ::check_duplicate_symbols::Lb {interval text args} {
	return \{$text\}
    }
    
    
    ## This is called on literal text which is delimited by braces
    proc ::check_duplicate_symbols::Lq {interval text args} {
	return \"$text\"
    }
    
    
    ## called whenever a backslash subsitution happens
    proc ::check_duplicate_symbols::Sb {interval text args} {
	return "\\$text"
    }
    
    
    ## called whenever a scalar variable substitution happens -- the value of $cell e.g.
    proc ::check_duplicate_symbols::Sv {interval text args} {
	return "\$[eval [lindex $args 0]]"
    }
    
    
    ## called on array substitution
    proc ::check_duplicate_symbols::Sa {interval text args} {
	foreach a [lrange $args 1 end] {
	    append result [eval $a]
	}
	return "\$[eval [lindex $args 0]]($result)"
    }
    
    
    ##  command substitution-- called when [commmand is executed] 
    proc ::check_duplicate_symbols::Sc {interval text args} {
	foreach a $args {
	    append cmd " " [eval $a]
	}
	return \[${cmd}\]
    }

    ## merge type--- honestly I don't know what the heck these are
    proc ::check_duplicate_symbols::Mr {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return ${result}
    }
    
    
    ## ditto
    proc ::check_duplicate_symbols::Mq {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return \"${result}\"
    }
    
    
    ## commands without {*}-construction
    proc ::check_duplicate_symbols::Cd {interval text args} {
	# grab the arguments to this command
	foreach a $args {
	    append cmd [eval $a] " "
	}
	
	# figure the type of the command itself
	set command_type [lindex [lindex $args 0] 2]
	
	puts "command_type = $command_type"
	
	puts "args0 : [lindex $args 0]"
	
	if { "proc" == $command_type } {
	    set proc_name [lindex [lindex $args 1] 2]
	    puts "found a proc : $proc_name at line number [::error_reporter::count_lines $interval]"
	}
	
	if { "namespace" == $command_type} {
	    set namespace_name [lindex [lindex $args 2] 2]
	    
	    puts "found a namespace : $namespace_name at line [::error_reporter::count_lines $interval]"
	    
	    set namespace_body [lindex [lindex $args 3] 2]
	    set namespace_body_interval [lindex [lindex $args 3] 1]
	    
	    # parse it
	    set namespace_block_parse [parse_tcl::basic_parse_script $namespace_body]
	    
	    # now dork offset the intervals, so we count the correct linenumbers...
	    set namespace_block_parse [parse_tcl::offset_intervals $namespace_block_parse [lindex $namespace_body_interval 0]]
	    
	    ::check_duplicate_symbols::walk $namespace_block_parse
	}
	
	if { "set" == $command_type} {
	    puts "found a variable settage: $args"
	}
	
	# carry on
	return ${cmd}
    }
    
    
    ##
    proc ::check_duplicate_symbols::Rs {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return \{\n$cmd\n\}
    }
    
    
    ##
    proc ::check_duplicate_symbols::Nc {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }
    
    
    ##
    proc ::check_duplicate_symbols::Ne {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }
}


##  Implements very basic syntax checking
#   more of a simply sanity check at this point
#   but we can make it more comprehensive...
namespace eval check_syntax {

    ## call this on parse tree to check the syntax
    proc ::check_syntax::walk {tree} {
	eval $tree
    }
    
    ## valid
    proc ::check_syntax::Lr {interval text args} {
	return $text
    }

    ## valid
    proc ::check_syntax::Lb {interval text args} {
	return \{$text\}
    }

    ## valid
    proc ::check_syntax::Lq {interval text args} {
	return \"$text\"
    }

    ## valid
    proc ::check_syntax::Sb {interval text args} {
	return "\\$text"
    }

    ## valid
    proc ::check_syntax::Sv {interval text args} {
	return "\$[eval [lindex $args 0]]"
    }

    ## valid
    proc ::check_syntax::Sa {interval text args} {
	foreach a [lrange $args 1 end] {
	    append result [eval $a]
	}
	return "\$[eval [lindex $args 0]]($result)"
    }

    ## valid
    proc ::check_syntax::Sc {interval text args} {
	set cmd ""
	
	foreach a $args {
	    append cmd " " [eval $a]
	}
	
	return \[${cmd}\]
    }

    ## valid
    proc ::check_syntax::Mr {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return ${result}
    }

    ## valid
    proc ::check_syntax::Mq {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return \"${result}\"
    }

    ## valid
    proc ::check_syntax::Cd {interval text args} {
	foreach a $args {
	    append cmd [eval $a] " "
	}
	return ${cmd}
    }

    ## valid
    proc ::check_syntax::Rs {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return \{\n$cmd\n\}
    }

    ## valid
    proc ::check_syntax::Nc {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }


    ## invalid -- print out the offending text
    proc ::check_syntax::Ne {interval text args} {
	error_reporter::error $interval "syntax error:  $text"
	
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }
}

## Dangling Pointer  Checker
#
#  Ok, the general idea is that  each expression is going to have
#  an abstract type:
#
#  * CELLS
#   NETS
#   PORTS
#   UNKNOWN -- kind of a "none of the above"
#
#  We will statically examine the variables to see what
#  type of object they have been assigned.
#
#  Other misc types for semantic analysis are:
#
#  * VAR_INIT
#
#  * "LITERAL <text>"  -- where <text> is the literal text
#
#  *  VAR_DEREF -- get the value fromm a variable
#  
#
namespace eval check_dangling_pointers {
    variable frame_index 0
    
    variable variables_holding_cells
    variable variables_holding_nets 
    variable variables_holding_ports
    
    array set variables_holding_cells {}
    array set variables_holding_nets  {}
    array set variables_holding_ports {}

    ## for parsing nested blocks of tcl code

    ## When parsing a nested code block when we DON'T want to import all of the
    #  variable names from the outer code block
    proc ::check_dangling_pointers::push_frame {} {
	variable frame_index
	
	variable variables_holding_cells
	variable variables_holding_nets 
	variable variables_holding_ports
	
	set frame_index [expr $frame_index + 1]
	
	set keys [array name variables_holding_cells -regexp "$frame_index,"]
	foreach key $keys {
	    set variables_holding_cells($key) INVALID
	}
	
	set keys [array name variables_holding_ports -regexp "$frame_index,"]
	foreach key $keys {
	    set variables_holding_ports($key) INVALID
	}    
	
	set keys [array name variables_holding_nets -regexp "$frame_index,"]
	foreach key $keys {
	    set variables_holding_nets($key) INVALID
	}
    }

    ## When parsing a nested code block and we DO want to import all of the
    # variable names fromm the outer code block
    proc ::check_dangling_pointers::push_copy_frame {} {
	variable frame_index
	
	variable variables_holding_cells
	variable variables_holding_nets 
	variable variables_holding_ports
	
	set new_frame_index [expr $frame_index + 1]
	
	set keys [array name variables_holding_cells -regexp "$frame_index,"]
	foreach key $keys {
	    regsub "$frame_index," $key "$new_frame_index," new_key
	    set variables_holding_cells($new_key) $variables_holding_cells($key)
	}
	
	set keys [array name variables_holding_ports -regexp "$frame_index,"]
	foreach key $keys {
	    regsub "$frame_index," $key "$new_frame_index," new_key
	    set variables_holding_ports($new_key) $variables_holding_ports($key)
	}    
	
	set keys [array name variables_holding_nets -regexp "$frame_index,"]
	foreach key $keys {
	    regsub "$frame_index," $key "$new_frame_index," new_key
	    set variables_holding_nets($new_key) $variables_holding_nets($key)
	}

	set frame_index $new_frame_index
    }

    ## called after we've parsed the nested code block
    proc ::check_dangling_pointers::pop_frame {} {
	variable frame_index
	
	set frame_index [expr $frame_index - 1]
	if { 0 > $frame_index } {
	    set frame_index 0
	}
    }

    ## just called to check and see if this isn't a dangerous variable
    proc ::check_dangling_pointers::validate_variable { variable_type variable_name } {
	# if its a cell variable, mark it as being valid
	if { "CELLS" == $variable_type } { 
	    validate_cell_variable $variable_name
	}
	
	# if it is a nets variable, mark it as being valid
	if { "NETS" == $variable_type } { 
	    validate_net_variable $variable_name
	}
	
	# if its a port variable, mark it as being valid for ports
	if { "PORTS" == $variable_type } { 
	    validate_port_variable $variable_name
	}
    }

    ## checks to see that cell variable is valid
    proc ::check_dangling_pointers::validate_cell_variable { variable_name } {
	variable frame_index
	variable variables_holding_cells

	set variables_holding_cells($frame_index,$variable_name) "OK"
    }

    ## checks to see that net variable is valid
    proc ::check_dangling_pointers::validate_net_variable { variable_name } {
	variable frame_index
	variable variables_holding_nets
	
	set variables_holding_nets($frame_index,$variable_name) "OK"
    }

    ## checks to see that port  variable is valid
    proc ::check_dangling_pointers::validate_port_variable { variable_name } {
	variable frame_index
	variable variables_holding_ports
	
	set variables_holding_ports($frame_index,$variable_name) "OK"
    }



    ## these are procedures for marking variables dangerous.  the "interval"
    #  parameter they take indicates the command which modified the database,
    #  which indeed made them dangerous

    proc ::check_dangling_pointers::invalidate_cell_variable { interval variable_name } {
	variable frame_index
	variable variables_holding_cells
	set variables_holding_cells($frame_index,$variable_name) [list "DANGEROUS" $interval]
    }

    ## mark a variable as having been delieted and therefore dangerous
    proc ::check_dangling_pointers::invalidate_net_variable { interval variable_name } {
	variable frame_index
	variable variables_holding_nets
	set variables_holding_nets($frame_index,$variable_name) [list "DANGEROUS" $interval]
    }

    ## mark a variable as having been delieted and therefore dangerous
    proc ::check_dangling_pointers::invalidate_port_variable { interval variable_name } {
	variable frame_index
	variable variables_holding_ports
	set variables_holding_ports($frame_index,$variable_name) [list "DANGEROUS" $interval]
    }


    ## mark all variable as potentiallyl having been deleted and therefore dangerous
    proc ::check_dangling_pointers::invalidate_all_variables_in_array { which_array interval } {
	variable frame_index
	variable $which_array
	
	set allkeys [array names $which_array]
	
	set keys [array names $which_array -regexp "$frame_index,"]
	
	foreach key $keys {
	    # ugly as sin-- isn't there a better way to do this?
	    if { "variables_holding_cells" == $which_array } {
		set variables_holding_cells($key) [list "DANGEROUS" $interval]
	    }
	    if { "variables_holding_nets" == $which_array } {
		set variables_holding_nets($key) [list "DANGEROUS" $interval]
	    }
	    if { "variables_holding_ports" == $which_array } {
		set variables_holding_ports($key) [list "DANGEROUS" $interval]
	    }
	}
    }

    ## blow everythign away--kinda blunt, but sometimes we can't prove
    # whether any specific variable has changed, we just know somme of them
    # might have changed, e.g. after a command like "opt_design"
    proc ::check_dangling_pointers::invalidate_all_variables { index } {
	invalidate_all_variables_in_array variables_holding_cells $index
	invalidate_all_variables_in_array variables_holding_nets $index
	invalidate_all_variables_in_array variables_holding_ports $index
    }


    ## this proceedure checks to see if a variable is dangerous,
    #  and if it is, it reports it
    proc ::check_dangling_pointers::check_is_variable_dangerous { interval variable_name } {
	variable frame_index
	variable variables_holding_cells
	variable variables_holding_nets
	variable variables_holding_ports
	
	if { [info exists variables_holding_cells($frame_index,$variable_name)]}  {
	    set v $variables_holding_cells($frame_index,$variable_name)
	    set t [lindex $v 0]
	    
	    if { "DANGEROUS" == $t } {
		set whacker_interval [lindex $v 1]
		set whacker_line_number [error_reporter::count_lines $whacker_interval]
		error_reporter::error $interval "Cell variable \"$variable_name\" was invalidated by command at line $whacker_line_number"
	    }
	}
	
	if { [info exists variables_holding_nets($frame_index,$variable_name)]}  {
	    set v $variables_holding_nets($frame_index,$variable_name)
	    set t [lindex $v 0]
	    
	    if { "DANGEROUS" == $t } {
		set whacker_interval [lindex $v 1]
		set whacker_line_number [error_reporter::count_lines $whacker_interval]
		error_reporter::error $interval "Net variable \"$variable_name\" was invalidated by command at line $whacker_line_number"
	    }
	}
	
	if { [info exists variables_holding_ports($frame_index,$variable_name)]}  {
	    set v $variables_holding_ports($frame_index,$variable_name)
	    set t [lindex $v 0]
	    
	    if { "DANGEROUS" == $t } {
		set whacker_interval [lindex $v 1]
		set whacker_line_number [error_reporter::count_lines $whacker_interval]
		error_reporter::error $interval "Port variable \"$variable_name\" was invalidated by command at line $whacker_line_number"
	    }
	}
    }

    ## top level call for the checker
    proc ::check_dangling_pointers::walk {tree} {
	if [catch {eval $tree} result] {
	    puts "Ignoring tcl eval error \"$result\" encountered during check for dangling pointers."
	}
    }

    ## Literal without any delimiters
    proc ::check_dangling_pointers::Lr {interval text args} {
	if { ![string compare $text "set"] } {
	    return VAR_INIT
	}
	
	if { ![string compare $text "variable"] } {
	    return VAR_INIT
	}
	
	if { ![string compare $text "get_cells"] } {
	    return CELLS
	}
	
	if { ![string compare $text "get_nets"] } {
	    return NETS
	}
	
	if { ![string compare $text "create_port"] } {
	    return PORTS
	}
	
	if { ![string compare $text "get_ports"] } {
	    return PORTS
	}
	
	if { "remove_cell" == $text } {
	    return REMOVE_CELL
	}
	
	if { "debug::remove_cell" == $text } {
	    return REMOVE_CELL
	}
	
	if { "puts" == $text } {
	    return "puts"
	}
	
	if { "remove_net" == $text } {
	    return REMOVE_NET
	}
	
	if { "debug::remove_net" == $text } {
	    return REMOVE_NET
	}
	
	if { "delete_port" == $text } {
	    return DELETE_PORT
	}
	
	if { "close_design" == $text } {
	    return CLOSE_DESIGN
	}
	
	if { "opt_design" == $text } {
	    return OPT_DESIGN
	}
	
	if { "foreach" == $text } {
	    return "foreach"
	}
	
	if { "if" == $text } {
	    return "if"
	}
	
	if { "proc" == $text } {
	    return "proc"
	}

	if { "namespace" == $text } {
	    return "namespace"
	}
	
	if { "eval" == $text } {
	    return "eval"
	}
	
	return "LITERAL $text"
    }


    ## Literal delimited by braces -- black box for now
    proc ::check_dangling_pointers::Lb {interval text args} {
	return UNKNOWN
    }

    ## Literal delimited by quotes -- black box for now
    proc ::check_dangling_pointers::Lq {interval text args} {
	return UNKNOWN
    }


    ## backslash substitution -- black box for now
    proc ::check_dangling_pointers::Sb {interval text args} {
	return UNKNOWN
    }


    ## scalar variable substitution -- must check whether we are
    # dereferencing a dangerous variable now!!!
    proc ::check_dangling_pointers::Sv {interval text args} {
	# extract the variable name from the parse tree
	set variable_name [lindex [lindex $args 0] 2]
	
	# check it
	check_is_variable_dangerous $interval $variable_name
	
	return "VAR_DEREF $variable_name"
    }


    ## array variable substitution -- must check whether we are
    # dereferencing a dangerous array variable now!!!!
    proc ::check_dangling_pointers::Sa {interval text args} {
	foreach a [lrange $args 1 end] {
	    append result [eval $a]
	}
	
	return UNKNOWN
    }

    ## command substitution -- must see if this is a command which
    #  returns a type of object we are interested in...
    proc ::check_dangling_pointers::Sc {interval text args} {
	
	foreach a $args {
	    lappend types [eval $a]
	}
	
	set inferred_type [lindex $types 0]
	
	return $inferred_type
    }


    ## merges type with no delimeters
    proc ::check_dangling_pointers::Mr {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return UNKNOWN
    }

    ## no-op
    proc ::check_dangling_pointers::Mq {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	
	return UNKNOWN
    }


    ## command without {*}-constructions
    proc ::check_dangling_pointers::Cd {interval text args} {
	# accumulate the types of the command and its arguments
	foreach a $args {
	    lappend types [eval $a]
	}

	# figure the type of the command itself
	set command_type [lindex $types 0]
	
	# depending upon what kind of command this is, take the
	# appropos action:
	
	if { $command_type == "VAR_INIT" } {
	    # find out the name of the variable which is being initialized
	    set variable_name [lindex [lindex $types 1] 1]
	    
	    # see if we can find out what type of object its being set to
	    set init_type [lindex $types 2]
	    
	    validate_variable $init_type $variable_name
	}
	
	if { $command_type == "REMOVE_CELL" } {
	    # if the arguments are a simple cell dereference, then 
	    # just invalidate variable name holding the cell being deleted.
	    # if its anything else, then invalidate everything, for 
	    # safety's sake
	    
	    set arg_type [lindex $types 1]
	    set arg_kind [lindex $arg_type 0]
	    if { "VAR_DEREF" == $arg_kind } {
		# we can just get by with invalidating this cell
		set variable_name [lindex [lindex $types 1] 1]
		#set variables_holding_cells($variable_name) "DANGEROUS"
		invalidate_cell_variable $interval $variable_name
	    } else {
		# we have to invalidate all variables holding cells, because we can't prove
		# that they are still valid
		invalidate_all_cell_variables $interval
	    }
	}
	
	if { $command_type == "REMOVE_NET" } {
	    # if the arguments are a simple cell dereference, then 
	    # just invalidate variable name holding the net being deleted.
	    # if its anything else, then invalidate everything, for 
	    # safety's sake
	    
	    set arg_type [lindex $types 1]
	    set arg_kind [lindex $arg_type 0]
	    if { "VAR_DEREF" == $arg_kind } {
		# we can just get by with invalidating this net
		set variable_name [lindex [lindex $types 1] 1]
		invalidate_net_variable $interval $variable_name
	    } else {
		# we have to invalidate all variables holding cells, because we can't prove
		# that they are still valid
		invalidate_all_net_variables $interval
	    }
	}
	
	if { $command_type == "DELETE_PORT" } {
	    # if the arguments are a simple cell dereference, then 
	    # just invalidate variable name holding the cell being deleted.
	    # if its anything else, then invalidate everything, for 
	    # safety's sake
	    
	    set arg_type [lindex $types 1]
	    set arg_kind [lindex $arg_type 0]
	    if { "VAR_DEREF" == $arg_kind } {
		# we can just get by with invalidating this cell
		set variable_name [lindex [lindex $types 1] 1]
		#set variables_holding_cells($variable_name) "DANGEROUS"
		invalidate_port_variable $interval $variable_name
	    } else {
		# we have to invalidate all variables holding cells, because we can't prove
		# that they are still valid
		invalidate_all_port_variables $interval
	    }
	}
	
	if { $command_type == "CLOSE_DESIGN" } {
	    # when we close the design, all bets are off on all of the variables
	    invalidate_all_variables $interval
	}
	
	if { $command_type == "OPT_DESIGN" } {
	    # when we close the design, all bets are off on all of the variables
	    invalidate_all_variables $interval
	}
	
	if { "foreach" == $command_type } {
	    # first, we must see if this loop is defining a new variable
	    # and see what type is being added to it...
	    
	    set loop_control_variable_type [lindex [lindex $types 1] 0]
	    set generator_type [lindex $types 2]
	    
	    if { "LITERAL" == $loop_control_variable_type } {
		set loop_control_variable_name [lindex [lindex $types 1] 1]
		validate_variable $generator_type $loop_control_variable_name
	    }
	    
	    # we must recursively check the code block
	    set code_block  [lindex [lindex $args 3] 2]
	    set code_block_interval [lindex [lindex $args 3] 1]
	    
	    set code_block_parse [parse_tcl::basic_parse_script $code_block]
	    
	    # now dork offset the intervals, so we count the correct linenumbers...
	    set code_block_parse [parse_tcl::offset_intervals $code_block_parse [lindex $code_block_interval 0]]
	    
	    check_dangling_pointers::walk $code_block_parse
	}
	
	if { "proc" == $command_type } {
	    # we must recursively check the proc code block
	    set proc_body [lindex $args 3]
	    
	    set proc_interval [lindex $proc_body 1]
	    set proc_code_block  [lindex $proc_body 2]
	    
	    # parse it
	    set proc_code_block_parse [parse_tcl::basic_parse_script $proc_code_block]
	    
	    # now dork offset the intervals, so we count the correct linenumbers...
	    set proc_code_block_parse [parse_tcl::offset_intervals $proc_code_block_parse [lindex $proc_interval 0]]
	    
	    # push frame, so as to account for variable scope.  Variables defined inside
	    # of the function are local to that function.
	    push_frame
	    
	    check_dangling_pointers::walk $proc_code_block_parse
	    # back to the calling frame
	    pop_frame
	}
	
	if { "namespace" == $command_type } {
	    set namespace_arg_type [lindex $types 1]
	    
	    if { "eval" == $namespace_arg_type } {
		set namespace_body [lindex [lindex $args 3] 2]
		set namespace_body_interval [lindex [lindex $args 3] 1]
		
		# parse it
		set namespace_block_parse [parse_tcl::basic_parse_script $namespace_body]
		
		# now dork offset the intervals, so we count the correct linenumbers...
		set namespace_block_parse [parse_tcl::offset_intervals $namespace_block_parse [lindex $namespace_body_interval 0]]
		
		# push frame, so as to account for variable scope.  Variables defined inside
		# of the function are local to that function.
		push_frame
		
		check_dangling_pointers::walk $namespace_block_parse
		# back to the calling frame
		pop_frame
	    }
	}
	
	if { "if" == $command_type } {
	    # grab the condition
	    set cond_block [lindex [lindex $args 1] 2]
	    set cond_block_interval [lindex [lindex $args 1] 1]
	    # parse it
	    set cond_block_parse [parse_tcl::basic_parse_script $cond_block]
	    # dork with the intervals, so we count the correct line numbers
	    
	    if { "" == $cond_block_interval } { return $command_type }
	    set cond_block_parse [parse_tcl::offset_intervals $cond_block_parse [lindex $cond_block_interval 0]]
	    # recursively check
	    check_dangling_pointers::walk $cond_block_parse
	    
	    set if_block [lindex [lindex $args 2] 2]
	    set if_block_interval [lindex [lindex $args 2] 1]
	    # parse it
	    set if_block_parse [parse_tcl::basic_parse_script $if_block]
	    # dork with the intervals, so we count the correct line numbers
	    if { "" == $if_block_interval } { return $command_type }
	    set if_block_parse [parse_tcl::offset_intervals $if_block_parse [lindex $if_block_interval 0]]
	    # recursively check
	    push_copy_frame
	    check_dangling_pointers::walk $if_block_parse
	    pop_frame
	    
	    if { [llength $args] > 3 } {
		set then_block [lindex [lindex $args 4] 2]
		set then_block_interval [lindex [lindex $args 4] 1]
		# parse it
		set then_block_parse [parse_tcl::basic_parse_script $then_block]
		# dork with the intervals, so we count the correct line numbers
		if { "" == $then_block_interval } { return $command_type }
		set then_block_parse [parse_tcl::offset_intervals $then_block_parse [lindex $then_block_interval 0]]
		# recursively check
		push_copy_frame
		check_dangling_pointers::walk $then_block_parse
		pop_frame
	    }
	}    
	
	return $command_type
    }

    ## no-op
    proc ::check_dangling_pointers::Rs {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }


    ## no-op
    proc ::check_dangling_pointers::Nc {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }

    ## Syntax Error:
    proc ::check_dangling_pointers::Ne {interval text args} {
	error_reporter::error $interval "syntax error:  $text"
	
	foreach a $args {
	    append cmd [eval $a]\n
	}
	
	return UNKNOWN
    }
}


## This checker enforces the requirements on tcl
#  files which provide a library:
#
#  * It must provide a package
# 
#  * All variables and proceedures and sub-namespaces must be defined, with the same name as the package
#
#  * There can be 
#
namespace eval lib_requirements {
    variable found_package_declaration 0
    variable found_namespace_declaration 0
    
    variable package_name ""
    variable namespace_name ""
    
    ## This returns true if we are working on a library file,
    # and false otherwise
    proc ::lib_requirements::is_library_file { file_name } {
	# strip off leading directory names, if they exist
	set file_name [file tail $file_name]
	
	set run_pos [string first "run" $file_name]
	if { 0 == $run_pos } {
	    return 0
	}
	
	set batch_pos [string first "batch" $file_name]
	if { 0 == $batch_pos } {
	    return 0
	}
	
	return 1
    }
    
    
    proc ::lib_requirements::walk { tree file_name { force_namespace_name "" } {ignore_package 0} } {
	# Summary : This enforces any package and library requirements we have for apps
	
	# tree : parse tree as returned by the tcl parser
	# file_name : name of the file the app is in
	# [force_namespace_name=""] : When not "", forces the namespace name to be the suppled param
	# [ignore_package=0] : when set to nonzero, ignores package requirements
	
	# Return Value : none.
	
	variable found_package_declaration
	variable found_namespace_declaration
	variable package_name
	variable namespace_name
	
	set found_package_declaration 0
	set found_namespace_declaration 0
	
	# not enforcing this anymore
	# first see if this applies:  if the script starts with "run" or
	# "batch" we don't enforce this requirement
	# if { ! [is_library_file $file_name] } {
	#     return
	# }
	
	eval $tree
	
	if { !$ignore_package && !$found_package_declaration } {
	    error_reporter::error_no_line "Did not find a package declaration"
	}
	
	if { !$found_namespace_declaration } {
	    error_reporter::error_no_line "Did not find a namespace declaration"
	}

        if { $package_name != "" && [string first $namespace_name $package_name]!=0 } {
	    error_reporter::error_no_line "package '$package_name' must be within namespace '$namespace_name'"
	}
	
	if { $force_namespace_name != "" && $force_namespace_name != $namespace_name } {
	    error_reporter::error_no_line "namespace '$namespace_name' should be '$force_namespace_name'"
	}
    }
    
    
    ## literal without delimeters -- the type is whatever the text is
    proc ::lib_requirements::Lr {interval text args} {
	return $text
    }

    ## literal delimited by braces -- the type is UNKNOWN
    proc ::lib_requirements::Lb {interval text args} {
	return UNKNOWN
    }

    ## literal delimited by quotes -- the type is UNKNOWN
    proc ::lib_requirements::Lq {interval text args} {
	return UNKNOWN
    }

    ## backslash substitution -- skip
    proc ::lib_requirements::Sb {interval text args} {
	return UNKNOWN
    }

    ## scalar variable substitution -- not checked
    proc ::lib_requirements::Sv {interval text args} {
	return UNKNOWN
    }

    ## array variable substitition -- not checked
    proc ::lib_requirements::Sa {interval text args} {
	foreach a [lrange $args 1 end] {
	    append result [eval $a]
	}
	return UNKNOWN
    }

    ## command substitution  -- fine because this isn't defining anything..
    proc ::lib_requirements::Sc {interval text args} {
	foreach a $args {
	    append cmd " " [eval $a]
	}
	return UNKNOWN
    }

    ## merge types
    proc ::lib_requirements::Mr {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return UNKNOWN
    }

    ## nothing checked
    proc ::lib_requirements::Mq {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return UNKNOWN
    }

    ## check command names for namespace requirements
    proc ::lib_requirements::Cd {interval text args} {
	variable found_package_declaration
	variable found_namespace_declaration
	
	variable package_name
	variable namespace_name
	
	foreach a $args {
	    append types [eval $a] " "
	}
	
	set command_type [lindex $types 0]
	
	if { "set" == $command_type } {
	    # get the putative  variable name
	    set s1 [lindex $args 1]
	    set putative_variable_name [lindex $s1 2]
	    
	    if { -1 == [string first "::" $putative_variable_name] } {
		error_reporter::error $interval "Variable should be set inside of a namespace"
	    }
	}
	
	if { "proc" == $command_type } {
	    if { ""==$namespace_name } {
		error_reporter::error $interval "Proc should be inside of a namespace, but no namespace is declared yet"
		return UNKNOWN
	    }
	    
	    set proc_name [lindex $types 1]
	    
	    # see if the variable name has the namespace name.  
	    # basically this just checks to see that the name is
	    # either of the form foo::bar* or ::foo::bar*
	    set namespace_pos [string first "::" $proc_name ]
	    
	    if { 0== $namespace_pos } {
		set trunc_proc_name [string range $proc_name 2 end]
		set namespace_pos [string first "::" $trunc_proc_name ]
	    }
	    
	    if { -1 == $namespace_pos } {
		error_reporter::error $interval "Proc should be inside of a namespace puts $namespace_pos"
	    }
	}
	
	# see if we've got a good namespace 
	if { "namespace" == $command_type} {
	    if { 4 != [llength $types] } {
		return UNKNOWN
	    }

	    
	    set namespace_command [lindex $types 1]
	    
	    if { "eval" != $namespace_command} {
		return UNKNOWN
	    }
	    
	    set namespace_name [lindex $types 2]
	    set found_namespace_declaration 1
	    
	    
	    set namespaces_seen($namespace_name) 1
	}
	
	
	# see if we've got a good package name
	if { "package" == $command_type } {
	    if { 4 != [llength $types] } {
		return UNKNOWN
	    }
	    
	    set package_command [lindex $types 1]
	    
	    if { "provide" == $package_command } {
		set package_name [lindex $types 2]
		set found_package_declaration 1
	    }
	}
	
	return UNKNOWN
    }

    ## null op
    proc ::lib_requirements::Rs {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }

    ## null op
    proc ::lib_requirements::Nc {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }

    ## null op
    proc ::lib_requirements::Ne {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }
}



## This checker enforces the requirements on tcl
#  files which provide a library:
#
#  * It must provide a package
# 
#  * All variables and proceedures and sub-namespaces must be defined, with the same name as the package
#
#  * There can be 
#
namespace eval package_namespace_requirements {
    variable found_package_declaration 0
    variable found_namespace_declaration 0
    
    variable package_name ""
    variable namespace_name ""

    ## This returns true if we are working on a library file,
    # and false otherwise
    proc ::package_namespace_requirements::is_library_file { file_name } {
	# strip off leading directory names, if they exist
	set file_name [file tail $file_name]
	
	set run_pos [string first "run" $file_name]
	if { 0 == $run_pos } {
	    return 0
	}
	
	set batch_pos [string first "batch" $file_name]
	if { 0 == $batch_pos } {
	    return 0
	}
	
	return 1
    }

    ## top level call for checker
    proc ::package_namespace_requirements::walk { tree file_name } {
	variable found_package_declaration
	variable found_namespace_declaration
	variable package_name
	variable namespace_name
	
	set found_package_declaration 0
	set found_namespace_declaration 0
	
	# first see if this applies:  if the script starts with "run" or
	# "batch" we don't enforce this requirement
	if { ! [is_library_file $file_name] } {
	    return
	}
	
	eval $tree
	
	if { !$found_package_declaration } {
	    error_reporter::error_no_line "Did not find a package declaration"
	}
	
	if { !$found_namespace_declaration } {
	    error_reporter::error_no_line "Did not find a namespace declaration"
	}
	
	if { $package_name != $namespace_name } {
	    error_reporter::error_no_line "package '$package_name' and namespace '$namespace_name' should be the same"
	}
    }


    ## literal without delimeters -- the type is whatever the text is
    proc ::package_namespace_requirements::Lr {interval text args} {
	return $text
    }

    ## literal delimited by braces -- the type is UNKNOWN
    proc ::package_namespace_requirements::Lb {interval text args} {
	return UNKNOWN
    }

    ## literal delimited by quotes -- the type is UNKNOWN
    proc ::package_namespace_requirements::Lq {interval text args} {
	return UNKNOWN
    }

    ## backslash substitution -- skip
    proc ::package_namespace_requirements::Sb {interval text args} {
	return UNKNOWN
    }

    ## scalar variable substitution -- not checked
    proc ::package_namespace_requirements::Sv {interval text args} {
	return UNKNOWN
    }

    ## array variable substitition -- not checked
    proc ::package_namespace_requirements::Sa {interval text args} {
	foreach a [lrange $args 1 end] {
	    append result [eval $a]
	}
	return UNKNOWN
    }

    ## command substitution  -- fine because this isn't defining anything..
    proc ::package_namespace_requirements::Sc {interval text args} {
	foreach a $args {
	    append cmd " " [eval $a]
	}
	return UNKNOWN
    }

    ## merge types
    proc ::package_namespace_requirements::Mr {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return UNKNOWN
    }

    ## nothing checked
    proc ::package_namespace_requirements::Mq {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return UNKNOWN
    }

    ## check command names for namespace requirements
    proc ::package_namespace_requirements::Cd {interval text args} {
	variable found_package_declaration
	variable found_namespace_declaration
	variable package_name
	variable namespace_name
	foreach a $args {
	    append types [eval $a] " "
	}
	
	set command_type [lindex $types 0]
	
	if { "proc" == $command_type } {
	    if { ""==$namespace_name } {
		error_reporter::error $interval "Proc should be inside of a namespace, but no namespace is declared yet"
		return UNKNOWN
	    }
	    
	    set proc_name [lindex $types 1]
	    
	    # see if the variable name has the namespace name.  
	    # basically this just checks to see that the name is
	    # either of the form foo::bar* or ::foo::bar*
	    set namespace_pos [string first "::" $proc_name ]
	    
	    if { 0== $namespace_pos } {
		set trunc_proc_name [string range $proc_name 2 end]
		set namespace_pos [string first "::" $trunc_proc_name ]
	    }
	    
	    if { -1 == $namespace_pos } {
		error_reporter::error $interval "Proc should be inside of a namespace puts $namespace_pos"
	    }
	}
	
	
	# see if we've got a good namespace 
	if { "namespace" == $command_type} {
	    if { 4 != [llength $types] } {
		return UNKNOWN
	    }
	    
	    set namespace_command [lindex $types 1]
	    
	    if { "eval" != $namespace_command} {
		return UNKNOWN
	    }
	    
	    set namespace_name [lindex $types 2]
	    set found_namespace_declaration 1
	    
	    
	    set namespaces_seen($namespace_name) 1
	}
	
	
	# see if we've got a good package name
	if { "package" == $command_type } {
	    if { 4 != [llength $types] } {
		return UNKNOWN
	    }
	    
	    set package_command [lindex $types 1]
	    
	    if { "provide" == $package_command } {
		set package_name [lindex $types 2]
		set found_package_declaration 1
	    }
	}
	
	return UNKNOWN
    }

    ## null op
    proc ::package_namespace_requirements::Rs {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }

    ## null op
    proc ::package_namespace_requirements::Nc {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }

    ## null op
    proc ::package_namespace_requirements::Ne {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }
}


## This is a very basic example of a parse tree walker. What it does is
# simply walks over the parse treee and reconstitutes the original script
# from the parse tree.  In other words, it does  exactly what it says: it 
# unparses it.  
# 
# Use this as a basic template: to create your own parse tree walker,
# just cut-n-paste this code and modify it for your own purposes.
namespace eval package_documentation_requirements {

    ## top level routine to call
    proc ::package_documentation_requirements::walk {tree} {
	eval $tree
    }
    
    ## This handles literal text which is not delimited by any quotes or braces,
    ## e.g. a variable name or a procedure name
    proc ::package_documentation_requirements::Lr {interval text args} {
	return $text
    }
    
    ## This is called on text which is delimited by braces
    proc ::package_documentation_requirements::Lb {interval text args} {
	return \{$text\}
    }

    ## This is called on literal text which is delimited by braces
    proc ::package_documentation_requirements::Lq {interval text args} {
	return \"$text\"
    }

    ## called whenever a backslash subsitution happens
    proc ::package_documentation_requirements::Sb {interval text args} {
	return "\\$text"
    }

    ## called whenever a scalar variable substitution happens -- the value of $cell e.g.
    proc ::package_documentation_requirements::Sv {interval text args} {
	return "\$[eval [lindex $args 0]]"
    }

    ## called on array substitution
    proc ::package_documentation_requirements::Sa {interval text args} {
	foreach a [lrange $args 1 end] {
	    append result [eval $a]
	}
	return "\$[eval [lindex $args 0]]($result)"
    }

    ##  command substitution-- called when [commmand is executed] 
    proc ::package_documentation_requirements::Sc {interval text args} {
	foreach a $args {
	    append cmd " " [eval $a]
	}
	return \[${cmd}\]
    }

    ## merge type--- honestly I don't know what the heck these are
    proc ::package_documentation_requirements::Mr {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return ${result}
    }

    ## ditto
    proc ::package_documentation_requirements::Mq {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return \"${result}\"
    }
proc ::package_documentation_requirements::parse_arg_usage_spec { argUsageSpec results } {
    # NOTE: This code was copied verbatim from args.tcl.That is not good, but
    # we don't currently have a better solution, and there is aleady other code 
    # in this file (e.g. get_documentation_section) that is also in args.tcl.


    # Summary: Returns 1 if the argument spec parsed out ok, 0 otherwise.
    
    # Argument Usage:
    # spec : a string which purports to hold an argument spec.
    # results : an array containing the results of parsing the argument spec
    
    # Return Value:
    # 1 is returned if we can recognize this as a well-formed argument spec
    # 0 is returned if we cannot recognize it as such.
    # 
    # If the function returns 1, then the following data are
    # communicated back to the caller via the "results" argument.
    # The following keys will have values set:
    # results(isOptional)    : 1 implies this is a spec for an optional argument
    # results(isPositional)  : 1 implies this is a spec for a positional argument,
    # results(isSwitch)      : 1 implies this is a boolean switch
    # results(defaultValue)  : if the spec indicates a default value for this
    #                        : argument, it is set to the indicated value.
    #                        : if there is no default, the value is <UNSET>
    # results(argName)       : a string which is the name of the argument
    # results(description)   : a string briefly describing the argument
    #
    # if the function returns 0, then the value of "results"
    # is undefined.
    
    # Categories:
    # system
    # non-user visible
    
    # enble pass-by-reference for the output arg
    upvar $results iResults
    # clear it out
    if { [array exists iResults] } {
        array unset iResults
    }
    
    if { [info exists iResults] } {
        unset iResults
    }
    
    # initialize to uninitialized :-)
    set iResults(isOptional)    {<UNSET>}
    set iResults(isPositional)  {<UNSET>}
    set iResults(isSwitch)      {<UNSET>}
    set iResults(defaultValue)  {<UNSET>}
    set iResults(argName)       {<UNSET>}
    set iResults(description)   {<UNSET>}
    
    # e.g. # [-report_name <arg> = report.txt] : when specified write a report to the specified name
    if { [regexp {[\s]*\[[\s]*-([^<]*)[\s]*\<arg\>[\s]*=[\s]*([^\]]*)\][\s]*:([^\n]*)} $argUsageSpec -> name def desc] } {
        set iResults(isOptional)    1
        set iResults(isPositional)  0
        set iResults(isSwitch)      0
        set iResults(defaultValue)  [string trim $def]
        set iResults(argName)       [string trim $name]
        set iResults(description)   [string trim $desc]
        return 1
    }
    
    # e.g.  # [-report_name <arg>] : when specified write a report to the specified name
    if { [regexp {[\s]*\[[\s]*-([^<]*)[\s]*\<arg\>[\s]*\][\s]*:([^\n]*)} $argUsageSpec -> name desc] } {
        set iResults(isOptional)    1
        set iResults(isPositional)  0
        set iResults(isSwitch)      0
        set iResults(argName)       [string trim $name]
        set iResults(description)   [string trim $desc]
        return 1
    }
    
    # e.g.  # [-no_whammies] : when specified, don't allow whamies
    if { [regexp {[\s]*\[[\s]*-(no_[^:]*)[\s]*\][\s]*:([^\n]*)} $argUsageSpec -> name desc] } {
        set iResults(isOptional)    1
        set iResults(isPositional)  0
        set iResults(isSwitch)      1
        set iResults(defaultValue)  1
        set iResults(argName)       [string trim $name]
        set iResults(description)   [string trim $desc]
        return 1
    }
    
    # e.g.  # [-use_smart_algorithm] : do it the good way, not the bad way
    if { [regexp {[\s]*\[[\s]*-([^:]*)[\s]*\][\s]*:([^\n]*)} $argUsageSpec -> name desc] } {
        set iResults(isOptional)    1
        set iResults(isPositional)  0
        set iResults(isSwitch)      1
        set iResults(defaultValue)  0
        set iResults(argName)       [string trim $name]
        set iResults(description)   [string trim $desc]
        return 1
    }
    
    # e.g. # [pattern=*]     : Match cell names against patterns
    if { [regexp {[\s]*\[[\s]*([^=]*)=[\s]*([^\]]*)\][\s]*:([^\n]*)} $argUsageSpec -> name def desc] } {
        set iResults(isOptional)    1
        set iResults(isPositional)  1
        set iResults(isSwitch)      0
        set iResults(defaultValue)  [string trim $def]
        set iResults(argName)       [string trim $name]
        set iResults(description)   [string trim $desc]
        return 1
    }
    
    # e.g.  # -report_name <arg> : write a report to the specified name
    if { [regexp {[\s]*[\s]*-([^<]*)[\s]*\<arg\>[\s]*[\s]*:([^\n]*)} $argUsageSpec -> name desc] } {
        set iResults(isOptional)    0
        set iResults(isPositional)  0
        set iResults(isSwitch)      0
        set iResults(argName)       [string trim $name]
        set iResults(description)   [string trim $desc]
        return 1
    }
    
    # e.g. # name : just a simple positional argument
    if { [regexp {[\s]*([^:]*):([^\n]*)} $argUsageSpec -> name desc] } {
        set iResults(isOptional)    0
        set iResults(isPositional)  1
        set iResults(isSwitch)      0
        set iResults(argName)       [string trim $name]
        set iResults(description)   [string trim $desc]
        return 1
    }
    return 0
}
    
    ## commands without {*}-construction
    proc ::package_documentation_requirements::Cd {interval text args} {
	foreach a $args {
	    append cmd [eval $a] " "
	}
	
	set command_type [lindex [lindex $args 0] 2]
	
	if { "proc" == $command_type } {
	    # Enforce the existence of a "Return Value" section
	    set extracted_section {}
	    if { [::documentation_utils::get_documentation_section $args "Return Value" extracted_section] } {
		# puts "found return value \n $extracted_section"
	    } else {
		error_reporter::error $interval "proceedure needs a \"Return Value\" section."
	    }
	    
	    # Enforce the existence of an "Argument Usage" section
	    set extracted_section {}
	    if { [::documentation_utils::get_documentation_section $args "Argument Usage" extracted_section] } {
		# now parse them using the reading scheme
		set argUsageSpecs [string trim $extracted_section]
		set argUsageSpecs [split $argUsageSpecs "\n"]
		foreach argUsageSpec $argUsageSpecs {
		    # parse the arg spec and extract the relevant info
		    array unset pr
		    array set pr {}
		    if {! [parse_arg_usage_spec $argUsageSpec pr] } {
			error_reporter::error $interval "invalid text \"$argUsageSpec\" in \"Argument Usage\" section."
		    }
		}
	    } else {
		error_reporter::error $interval "proceedure needs a \"Argument Usage\" section."
	    }
	    
	    # Enforce the existence of a "Summary" section
	    set extracted_section {}
	    if { [::documentation_utils::get_documentation_section $args "Summary" extracted_section] } {
		# puts "found return value \n $extracted_section"
	    } else {
		error_reporter::error $interval "proceedure needs a \"Summary\" section."
	    }
	}
	
	if { "namespace" == $command_type } {
            set namespace_cmd           [lindex [lindex $args 2] 2]
	    set namespace_body          [lindex [lindex $args 3] 2]
	    set namespace_body_interval [lindex [lindex $args 3] 1]

            if { "eval" == $namespace_cmd } {
                # parse it
                set namespace_block_parse [parse_tcl::basic_parse_script $namespace_body]
	    
                # now dork offset the intervals, so we count the correct linenumbers...
                set namespace_block_parse [parse_tcl::offset_intervals $namespace_block_parse [lindex $namespace_body_interval 0]]

                # recursiveliy check
                ::package_documentation_requirements::walk $namespace_block_parse
            }
	}
	
	return ${cmd}
    }
    
    ##
    proc ::package_documentation_requirements::Rs {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return \{\n$cmd\n\}
    }
    
    ##
    proc ::package_documentation_requirements::Nc {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }
    
    ##
    proc ::package_documentation_requirements::Ne {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }
}




namespace eval extract_app_documentation_summary {
    variable found_summary ""
    
    ## top level routine to call
    proc walk {tree} {
	variable found_summary
	
	set found_summary ""
	eval $tree
	return $found_summary
    }
    
    ## This handles literal text which is not delimited by any quotes or braces,
    ## e.g. a variable name or a procedure name
    proc ::extract_app_documentation_summary::Lr {interval text args} {
	return $text
    }
    
    ## This is called on text which is delimited by braces
    proc ::extract_app_documentation_summary::Lb {interval text args} {
	return \{$text\}
    }
    
    ## This is called on literal text which is delimited by braces
    proc ::extract_app_documentation_summary::Lq {interval text args} {
	return \"$text\"
    }

    ## called whenever a backslash subsitution happens
    proc ::extract_app_documentation_summary::Sb {interval text args} {
	return "\\$text"
    }

    ## called whenever a scalar variable substitution happens -- the value of $cell e.g.
    proc ::extract_app_documentation_summary::Sv {interval text args} {
	return "\$[eval [lindex $args 0]]"
    }

    ## called on array substitution
    proc ::extract_app_documentation_summary::Sa {interval text args} {
	foreach a [lrange $args 1 end] {
	    append result [eval $a]
	}
	return "\$[eval [lindex $args 0]]($result)"
    }

    ##  command substitution-- called when [commmand is executed] 
    proc ::extract_app_documentation_summary::Sc {interval text args} {
	foreach a $args {
	    append cmd " " [eval $a]
	}
	return \[${cmd}\]
    }

    ## merge type--- honestly I don't know what the heck these are
    proc ::extract_app_documentation_summary::Mr {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return ${result}
    }

    ## ditto
    proc ::extract_app_documentation_summary::Mq {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return \"${result}\"
    }

    ## commands without {*}-construction
    proc ::extract_app_documentation_summary::Cd {interval text args} {
	foreach a $args {
	    append cmd [eval $a] " "
	}
	
	set cmd0 [lindex $cmd 0]
	
	if { "namespace" == $cmd0 } {
	    set namespace_body [lindex [lindex $args 3] 2]
	    set namespace_body_interval [lindex [lindex $args 3] 1]
	    
	    # parse it
	    set namespace_block_parse [parse_tcl::basic_parse_script $namespace_body]
	    
	    # now dork offset the intervals, so we count the correct linenumbers...
	    set namespace_block_parse [parse_tcl::offset_intervals $namespace_block_parse [lindex $namespace_body_interval 0]]
	    
	    extract_app_documentation_summary::walk $namespace_block_parse
	}
	
	return ${cmd}
    }

    ##
    proc ::extract_app_documentation_summary::Rs {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return \{\n$cmd\n\}
    }
    
    ##
    proc ::extract_app_documentation_summary::Nc {interval text args} {
	variable found_summary
	
	# we only get the first one here 
	if { "" != $found_summary} {
	    return;
	}
	
	set regExpString "Summary\[ \\t\]*:\[ \\t\]*(\[^\\n\]*)"
	
	# find where the section starts
	if { [regexp -indices $regExpString $text nspec pos] } {
	    set found_summary [string range $text [lindex $pos 0] [lindex $pos 1]]
	}
	
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }

    ##
    proc ::extract_app_documentation_summary::Ne {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }
}

namespace eval proper_commenting {
    ## This enforces the Doxygen-style commenting conventions.  Not really using those
    # right now, but kept them in for purposes of example
    
    variable looking_for_comment  1
    variable found_proper_comment 0


    ## top level call for checker
    proc ::proper_commenting::walk {tree} {
	variable looking_for_comment
	variable found_proper_comment
	
	set looking_for_comment 1
	set found_proper_comment 0
	
	eval $tree
    }
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Lr {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { $looking_for_comment } {
	    set found_proper_comment 0
	}
	
	return $text
    }
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Lb {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { $looking_for_comment } {
	    set found_proper_comment 0
	}
	
	return UNKNOWN
    }
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Lq {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { $looking_for_comment } {
	    set found_proper_comment 0
	}
	
	return UNKNOWN
    }
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Sb {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { $looking_for_comment } {
	    set found_proper_comment 0
	}
	
	return UNKNOWN
    }
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Sv {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { $looking_for_comment } {
	    set found_proper_comment 0
	}
	
	return UNKNOWN
    }
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Sa {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { $looking_for_comment } {
	    set found_proper_comment 0
	}
	
	foreach a [lrange $args 1 end] {
	    append result [eval $a]
	}
	return UNKNOWN
    }
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Sc {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { $looking_for_comment } {
	    set found_proper_comment 0
	}
	
	foreach a $args {
	    append cmd " " [eval $a]
	}
	return UNKNOWN
    }
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Mr {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { $looking_for_comment } {
	    set found_proper_comment 0
	}
	
	foreach a $args {
	    append result [eval $a]
	}
	return UNKNOWN
    }
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Mq {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { $looking_for_comment } {
	    set found_proper_comment 0
	}
	
	foreach a $args {
	    append result [eval $a]
	}
	return UNKNOWN
    }
    
    ## here we check to see if the commands have the proper comments directly above them
    # as per the coding standards
    proc ::proper_commenting::Cd {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	# turn off comment detection during arg of proc processing---we're testing wehther
	# the procs are well-commented
	set looking_for_comment 0
	
	foreach a $args {
	    append types [eval $a] " "
	}
	
	set looking_for_comment 1
	
	if { "proc" == [lindex $types 0] } {
	    if { $found_proper_comment } {
	    } else {
		error_reporter::error $interval "proceedure needs proper comment"
	    }
	}
	
	if { "namespace" == [lindex $types 0] } {
	    set namespace_arg_type [lindex $types 1]
	    if { "eval" == $namespace_arg_type } {
		set namespace_body [lindex [lindex $args 3] 2]
		set namespace_body_interval [lindex [lindex $args 3] 1]
		
		# parse it
		set namespace_block_parse [parse_tcl::basic_parse_script $namespace_body]
		
		# now dork offset the intervals, so we count the correct linenumbers...
		set namespace_block_parse [parse_tcl::offset_intervals $namespace_block_parse [lindex $namespace_body_interval 0]]
		
		# recursively check
		proper_commenting::walk $namespace_block_parse
	    }
	}
	
	set found_proper_comment 0
	return UNKNOWN
    }
    
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Rs {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { $looking_for_comment } {
	    set found_proper_comment 0
	}
	
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Nc {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { !$looking_for_comment }  {
	    return UNKNOWN
	}
	
	# see if we've got a proper comment
	
	set pound_pos [string first "\#" $text ]
	
	if { 0 == $pound_pos } {
	    set found_proper_comment 1
	}
	
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }
    
    ## since this is not a comment, if we are looking for a proper comment,
    # we set the state variable which indicates we have not found one
    proc ::proper_commenting::Ne {interval text args} {
	variable looking_for_comment
	variable found_proper_comment
	
	if { $looking_for_comment } {
	    set found_proper_comment 0
	}
	
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return UNKNOWN
    }
}


namespace eval proper_documentation {
    
    ## top level routine to call
    proc ::proper_documentation::walk {tree} {
	eval $tree
    }
    
    ## This handles literal text which is not delimited by any quotes or braces,
    ## e.g. a variable name or a procedure name
    proc ::proper_documentation::Lr {interval text args} {
	return $text
    }

    ## This is called on text which is delimited by braces
    proc ::proper_documentation::Lb {interval text args} {
	return \{$text\}
    }

    ## This is called on literal text which is delimited by braces
    proc ::proper_documentation::Lq {interval text args} {
	return \"$text\"
    }

    ## called whenever a backslash subsitution happens
    proc ::proper_documentation::Sb {interval text args} {
	return "\\$text"
    }

    ## called whenever a scalar variable substitution happens -- the value of $cell e.g.
    proc ::proper_documentation::Sv {interval text args} {
	return "\$[eval [lindex $args 0]]"
    }

    ## called on array substitution
    proc ::proper_documentation::Sa {interval text args} {
	foreach a [lrange $args 1 end] {
	    append result [eval $a]
	}
	return "\$[eval [lindex $args 0]]($result)"
    }

    ##  command substitution-- called when [commmand is executed] 
    proc ::proper_documentation::Sc {interval text args} {
	foreach a $args {
	    append cmd " " [eval $a]
	}
	return \[${cmd}\]
    }

    ## merge type--- honestly I don't know what the heck these are
    proc ::proper_documentation::Mr {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return ${result}
    }

    ## ditto
    proc ::proper_documentation::Mq {interval text args} {
	foreach a $args {
	    append result [eval $a]
	}
	return \"${result}\"
    }

    ## commands without {*}-construction
    proc ::proper_documentation::Cd {interval text args} {
	foreach a $args {
	    append cmd [eval $a] " "
	}
	
	puts "yeah inside of cd $cmd"
	
	return ${cmd}
    }

    ##
    proc ::proper_documentation::Rs {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return \{\n$cmd\n\}
    }

    ##
    proc ::proper_documentation::Nc {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }

    ##
    proc ::proper_documentation::Ne {interval text args} {
	foreach a $args {
	    append cmd [eval $a]\n
	}
	return "\#$text"
    }

}

##
namespace eval file_handling {

    ## global variable which holds the unprocessed contents of the
    # file to be linted as a string
    set ::file_handling::file_contents {}

    ## reads <filename> into the file_contents variable
    proc ::file_handling::read_file { file_name } {
	global file_handling::file_ontents
	
	set fp [open $file_name "r"]
	set file_handling::file_contents [read $fp]
	close $fp
    }


    ## makes sure the file exists before it tries to open it
    proc ::file_handling::sanitize_script_file_name { file_name} {
	if { [file exists $file_name] } {
	    return 1;
	}
	
	puts "script $file_name doesn't exist"
	return 0
    }


    ## extract provider of this script
    proc ::file_handling::extract_provider {path} {
        if {[regexp {tclapp/([^/]*)} $path match var1]} {
            return $var1
        } else {
            puts "could not determine provider from script '$path'"
            return ""
        }
    }

    ## extract appname of this script
    proc ::file_handling::extract_appname {provider path} {
        if {[regexp [subst -nocommands {tclapp/$provider/([^/]*)}] $path match var1]} {
            return $var1
        } else {
            puts "could not determine appname from script '$path'"
            return ""
        }
    }
}


namespace eval lint {

    ## this is the top level controller for the linter.  
    #  ensures things are set up correctly, global state is
    #  initialized, and calls the checkers one-by-one to do
    #  the checking required
    proc ::lint::lint_file { file_name } {
	global error_reporter::errors

	if { ! [file_handling::sanitize_script_file_name $file_name] }  {
	    return 0;
	}
	
	# wipe out pre-existing state, if any
	set error_reporter::errors ""
	
        # determine provider from parent dir name immediately below
        # tclapp/ dir
        set provider [file_handling::extract_provider $file_name]
        set appname [file_handling::extract_appname $provider $file_name]
	
	# read in the file
	file_handling::read_file $file_name
	
	# Parse it
	set parse [parse_tcl::basic_parse_script $file_handling::file_contents]
	
	# run the checkers
	check_syntax::walk                       $parse
	check_dangling_pointers::walk            $parse
	lib_requirements::walk                   $parse $file_name ::tclapp::${provider}::${appname} 1
	check_namespace_export::walk             $parse
	package_documentation_requirements::walk $parse
	#check_duplicate_symbols::check_symbols  $parse
	
	#    proper_commenting::walk        $parse
	#    proper_documentation::walk     $parse
	
	# success!
        return 1
    }


    proc ::lint::check_syntax { file_name } {
	# Summary : Check to see if the file_name has 
	
	# Argument Usage:
	# file_name : name of file to check
	
	# Return Value:
	# Returns a string which is the error messges, if found
	# Returns empty string on success
	
	global error_reporter::errors
	
	if { ! [file_handling::sanitize_script_file_name $file_name] }  {
	    return 0;
	}
	
	# wipe out pre-existing state, if any
	set error_reporter::errors ""
	
	# read in the file
	file_handling::read_file $file_name
	
	# Parse it
	set parse [parse_tcl::basic_parse_script $file_handling::file_contents]
	
	# run the checker
	::check_syntax::walk $parse
	
	# return the error message
	return $error_reporter::errors
    }


    proc ::lint::check_dangling_pointers { file_name } {
	# Summary : Check to see if the file_name has 
	
	# Argument Usage:
	# file_name : name of file to check
	
	# Return Value:
	# Returns a string which is the error messges, if found
	# Returns empty string on success

	global error_reporter::errors
	
	if { ! [file_handling::sanitize_script_file_name $file_name] }  {
	    return 0;
	}
	
	# wipe out pre-existing state, if any
	set error_reporter::errors ""
	
	# read in the file
	file_handling::read_file $file_name
	
	# Parse it
	set parse [parse_tcl::basic_parse_script $file_handling::file_contents]
	
	# run the checker
	::check_dangling_pointers::walk $parse
	
	# return the error message
	return $error_reporter::errors
    }


    proc ::lint::check_package_namespace { file_name } {
	# Summary : Check to see if the file_name has 
	
	# Argument Usage:
	# file_name : name of file to check
	
	# Return Value:
	# Returns a string which is the error messges, if found
	# Returns empty string on success
	
	global error_reporter::errors
	
	if { ! [file_handling::sanitize_script_file_name $file_name] }  {
	    return 0;
	}
	
	# wipe out pre-existing state, if any
	set error_reporter::errors ""
	
	# read in the file
	file_handling::read_file $file_name
	
	# Parse it
	set parse [parse_tcl::basic_parse_script $file_handling::file_contents]
	
	# run the checkers
	package_namespace_requirements::walk $parse $file_name
	
	# return the error message
	return $error_reporter::errors
    }

proc ::lint::check_package_documentation { file_name } {
	# Summary : Check to see if the package in file_name is properly documented
	
	# Argument Usage:
	# file_name : name of file to check
	
	# Return Value:
	# Returns a string which is the error messges, if found
	# Returns empty string on success
	
	global error_reporter::errors
	
	if { ! [file_handling::sanitize_script_file_name $file_name] }  {
	    return 0;
	}
	
	# wipe out pre-existing state, if any
	set error_reporter::errors ""
	
	# read in the file
	file_handling::read_file $file_name
	
	# Parse it
	set parse [parse_tcl::basic_parse_script $file_handling::file_contents]
	
	# run the checkers
	package_documentation_requirements::walk $parse
	
	# return the error message
	return $error_reporter::errors
    }


    proc ::lint::extract_package_documentation_summary { file_name } {
	# Summary : Finds the package summary, extracts it, and return it.
	
	# Argument Usage:
	# file_name : name of file to check
	
	# Return Value:
	# Returns a string which is the summary description of the package,if it exists
	# Returns empty string if none could be found
	
	global error_reporter::errors
	
	if { ! [file_handling::sanitize_script_file_name $file_name] }  {
	    return 0;
	}
	
	# wipe out pre-existing state, if any
	set error_reporter::errors ""
	
	# read in the file
	file_handling::read_file $file_name
	
	# Parse it
	set parse [parse_tcl::basic_parse_script $file_handling::file_contents]
	
	# return the summary, if found
	set extracted [ extract_app_documentation_summary::walk $parse]
	
	puts $extracted
	
	return $extracted
    }


    ## this prints out an example template file so that the user's can
    # easily see the proper syntax for declaring packages, nameespaces, etc.
    proc ::lint::print_template {} {
        puts "package require Vivado 1.2014.1"
	puts ""
        puts "namespace eval ::tclapp::<provider>::<app> \{"
        puts "    namespace export <proc> ..."
        puts "\}"
	puts ""
	puts "proc ::tclapp::<provider>::<app>::<proc> \{ arg1 arg2 \} \{"
	puts "    # Summary : Put 1-line description of function here"
	puts " "
	puts "    # Argument Usage:"
	puts "    # arg1 : description of arg1"
	puts "    # arg2 : description of arg1"
	puts ""
	puts "    # Return Value:"
	puts "    # describe the return value here, if any"
	puts ""
	puts "    return \[llength \[get_nets\]\]"
	puts "\}"
    }


    ##  the main function is going to be the first functions which is invoked.
    #   it will make sure that there are many differing 
    proc ::lint::main {args} {
        set argc [llength $args]
        set argv $args
	
	global error_reporter::errors
	
	# this detects whether we are using this as a stand-alone 
	# script, or as part of a script which defines commmands inside of
	# the tool.
	if { $argc < 1 } {
	    # this is being sourced, so just bail
	    return
	}
	
	# if we get here, then we're on the command line and should do some stuff.
	set arg0 [lindex $argv 0]

        if { [file tail $arg0] == "pkgIndex.tcl" } {
            return
        }
	
	# see if we are requested to print out the template
	if { "-print_template" == $arg0} {
	    lint::print_template
	    return
	}
	
	# 
	if { "-check_syntax" == $arg0 } {
	    lint::check_syntax [lindex $argv 1]
	    puts $error_reporter::errors
	    return
	}
	
	# 
	if { "-check_dangling_pointers" == $arg0 } {
	    lint::check_dangling_pointers [lindex $argv 1]
	    puts $error_reporter::errors
	    return
	}
	
	# 
	if { "-check_package_namespace" == $arg0 } {
	    lint::check_package_namespace [lindex $argv 1]
	    puts $error_reporter::errors
	    return
	}
	
	# 
	if { "-check_package_documentation" == $arg0 } {
	    lint::check_package_documentation [lindex $argv 1]
	    puts $error_reporter::errors
	    return
	}
	
	# 
	if { "-extract_package_documentation_summary" == $arg0 } {
	    lint::extract_package_documentation_summary [lindex $argv 1]
	    return
	}
	
	# interpret the arg as a filename, attempt to lint that file...
	if { [lint::lint_file $arg0] && $error_reporter::errors != ""} {
	    # report the errors
            puts "Errors were found in $arg0"
            puts $error_reporter::errors
	}
    }
}

# run main.  If this is being run from the unix command line, then
# this runs the checker on the supplied file.  if its just being
# sourced, then this is a null-op
if {[info exists argv]} {
    lint::main $argv
}
